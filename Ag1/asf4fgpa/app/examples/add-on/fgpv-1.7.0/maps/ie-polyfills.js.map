{"version":3,"sources":["ie-polyfills.js"],"names":["Array","prototype","fill","value","this","TypeError","O","Object","len","length","start","arguments","relativeStart","k","Math","max","min","end","relativeEnd","undefined","final","find","predicate","list","thisArg","i","call","findIndex","from","toStr","toString","isCallable","fn","toInteger","number","Number","isNaN","isFinite","floor","abs","maxSafeInteger","pow","toLength","arrayLike","C","items","T","mapFn","kValue","A","assign","target","index","source","key","hasOwnProperty","module","exports","require","global","inRange","a","includes","array","item","indexOf","ToDictionary","o","stringToCodePoints","string","s","String","n","u","c","charCodeAt","push","d","b","codePointsToString","code_points","cp","fromCharCode","isASCIIByte","Stream","tokens","slice","reverse","decoderError","fatal","opt_code_point","encoderError","code_point","Decoder","Encoder","getEncoding","label","trim","toLowerCase","label_to_encoding","indexCodePointFor","pointer","indexPointerFor","name","Error","indexGB18030RangesCodePointFor","offset","code_point_offset","idx","entry","indexGB18030RangesPointerFor","pointer_offset","indexShiftJISPointerFor","indexBig5PointerFor","index_","lastIndexOf","TextDecoder","options","DEFAULT_ENCODING","_encoding","_decoder","_ignoreBOM","_BOMseen","_error_mode","_do_not_flush","encoding","RangeError","decoders","dec","Boolean","defineProperty","ignoreBOM","TextEncoder","_encoder","_fatal","enc","encoders","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","handler","stream","bite","end_of_stream","finished","prepend","UTF8Encoder","count","bytes","temp","SingleByteDecoder","SingleByteEncoder","isASCIICodePoint","GB18030Decoder","gb18030_first","gb18030_second","gb18030_third","buffer","lead","GB18030Encoder","gbk_flag","trail","byte1","byte2","byte3","byte4","Big5Decoder","big5_lead","Big5Encoder","EUCJPDecoder","eucjp_jis0212_flag","eucjp_lead","EUCJPEncoder","ISO2022JPDecoder","states","ASCII","Roman","Katakana","LeadByte","TrailByte","EscapeStart","Escape","iso2022jp_decoder_state","iso2022jp_decoder_output_state","iso2022jp_lead","iso2022jp_output_flag","state","output_flag","ISO2022JPEncoder","jis0208","iso2022jp_state","ShiftJISDecoder","shiftjis_lead","lead_offset","ShiftJISEncoder","EUCKRDecoder","euckr_lead","EUCKREncoder","convertCodeUnitToBytes","code_unit","utf16be","UTF16Decoder","utf16_be","utf16_lead_byte","utf16_lead_surrogate","lead_surrogate","UTF16Encoder","concat","XUserDefinedDecoder","XUserDefinedEncoder","endOfStream","read","pop","token","isArray","unshift","shift","encodings","labels","heading","forEach","category","get","decode","input","serializeStream","ArrayBuffer","Uint8Array","byteOffset","byteLength","result","input_stream","output","apply","encode","opt_string","EncodingIndexes","serializeSvgContent","element","nodeName","attributes","attribute","nodeValue","replace","childNodes","child","nodeType","newSvg","svg","well","document","createElement","SVG","Parent","appendChild","writeDataToDom","node","cloneNode","innerHTML","il","firstChild","SVGElement","enumerable","configurable","RV","window","_deferredPolyfills","extend","Element","lib$es6$promise$utils$$objectOrFunction","x","lib$es6$promise$utils$$isFunction","lib$es6$promise$asap$$setScheduler","scheduleFn","lib$es6$promise$asap$$customSchedulerFn","lib$es6$promise$asap$$setAsap","asapFn","lib$es6$promise$asap$$asap","lib$es6$promise$asap$$useNextTick","process","nextTick","lib$es6$promise$asap$$flush","lib$es6$promise$asap$$useVertxTimer","lib$es6$promise$asap$$vertxNext","lib$es6$promise$asap$$useMutationObserver","iterations","observer","lib$es6$promise$asap$$BrowserMutationObserver","createTextNode","observe","characterData","data","lib$es6$promise$asap$$useMessageChannel","channel","MessageChannel","port1","onmessage","port2","postMessage","lib$es6$promise$asap$$useSetTimeout","setTimeout","lib$es6$promise$asap$$len","callback","lib$es6$promise$asap$$queue","arg","lib$es6$promise$asap$$attemptVertx","r","vertx","runOnLoop","runOnContext","e","lib$es6$promise$then$$then","onFulfillment","onRejection","parent","constructor","lib$es6$promise$$internal$$noop","lib$es6$promise$$internal$$PROMISE_ID","lib$es6$promise$$internal$$makePromise","_state","lib$es6$promise$$internal$$invokeCallback","_result","lib$es6$promise$$internal$$subscribe","lib$es6$promise$promise$resolve$$resolve","object","Constructor","promise","lib$es6$promise$$internal$$resolve","lib$es6$promise$$internal$$selfFulfillment","lib$es6$promise$$internal$$cannotReturnOwn","lib$es6$promise$$internal$$getThen","then","error","lib$es6$promise$$internal$$GET_THEN_ERROR","lib$es6$promise$$internal$$tryThen","fulfillmentHandler","rejectionHandler","lib$es6$promise$$internal$$handleForeignThenable","thenable","sealed","lib$es6$promise$$internal$$fulfill","reason","lib$es6$promise$$internal$$reject","_label","lib$es6$promise$$internal$$handleOwnThenable","lib$es6$promise$$internal$$FULFILLED","lib$es6$promise$$internal$$REJECTED","lib$es6$promise$$internal$$handleMaybeThenable","maybeThenable","lib$es6$promise$then$$default","resolve","lib$es6$promise$promise$resolve$$default","lib$es6$promise$$internal$$publishRejection","_onerror","lib$es6$promise$$internal$$publish","lib$es6$promise$$internal$$PENDING","_subscribers","subscribers","settled","detail","lib$es6$promise$$internal$$ErrorObject","lib$es6$promise$$internal$$tryCatch","lib$es6$promise$$internal$$TRY_CATCH_ERROR","succeeded","failed","hasCallback","lib$es6$promise$$internal$$initializePromise","resolver","lib$es6$promise$$internal$$nextId","lib$es6$promise$$internal$$id","lib$es6$promise$promise$all$$all","entries","lib$es6$promise$enumerator$$default","lib$es6$promise$promise$race$$race","lib$es6$promise$utils$$isArray","reject","lib$es6$promise$promise$reject$$reject","lib$es6$promise$promise$$needsResolver","lib$es6$promise$promise$$needsNew","lib$es6$promise$promise$$Promise","lib$es6$promise$enumerator$$Enumerator","_instanceConstructor","_input","_remaining","_enumerate","lib$es6$promise$enumerator$$validationError","lib$es6$promise$polyfill$$polyfill","local","self","Function","P","Promise","cast","lib$es6$promise$promise$$default","lib$es6$promise$utils$$_isArray","lib$es6$promise$asap$$scheduleFlush","lib$es6$promise$asap$$browserWindow","lib$es6$promise$asap$$browserGlobal","MutationObserver","WebKitMutationObserver","lib$es6$promise$asap$$isNode","lib$es6$promise$asap$$isWorker","Uint8ClampedArray","importScripts","random","substring","lib$es6$promise$promise$all$$default","lib$es6$promise$promise$race$$default","lib$es6$promise$promise$reject$$default","all","race","_setScheduler","_setAsap","_asap","catch","_eachEntry","_settledAt","_willSettleAt","enumerator","lib$es6$promise$polyfill$$default","lib$es6$promise$umd$$ES6Promise","polyfill","define","endsWith","searchString","position","subjectString","lastIndex","repeat","str","Infinity","rpt","startsWith","substr"],"mappings":"AAEKA,MAAMC,UAAUC,OACjBF,MAAMC,UAAUC,KAAO,SAAUC,GAG7B,GAAY,MAARC,KACA,KAAM,IAAIC,WAAU,8BA4BxB,KAzBA,GAAIC,GAAIC,OAAOH,MAGXI,EAAMF,EAAEG,SAAW,EAGnBC,EAAQC,UAAU,GAClBC,EAAgBF,GAAS,EAGzBG,EAAID,EAAgB,EACpBE,KAAKC,IAAIP,EAAMI,EAAe,GAC9BE,KAAKE,IAAIJ,EAAeJ,GAGxBS,EAAMN,UAAU,GAChBO,EAAsBC,SAARF,EACdT,EAAMS,GAAO,EAGbG,EAAQF,EAAc,EACtBJ,KAAKC,IAAIP,EAAMU,EAAa,GAC5BJ,KAAKE,IAAIE,EAAaV,GAGnBK,EAAIO,GACPd,EAAEO,GAAKV,EACPU,GAIJ,OAAOP,KAQVN,MAAMC,UAAUoB,OACjBrB,MAAMC,UAAUoB,KAAO,SAAUC,GAC7B,GAAa,OAATlB,KACA,KAAM,IAAIC,WAAU,mDAExB,IAAyB,kBAAdiB,GACP,KAAM,IAAIjB,WAAU,+BAOxB,KAAK,GAFDF,GAHAoB,EAAOhB,OAAOH,MACdK,EAASc,EAAKd,SAAW,EACzBe,EAAUb,UAAU,GAGfc,EAAI,EAAGA,EAAIhB,EAAQgB,IAExB,GADAtB,EAAQoB,EAAKE,GACTH,EAAUI,KAAKF,EAASrB,EAAOsB,EAAGF,GAClC,MAAOpB,KAYlBH,MAAMC,UAAU0B,YACjB3B,MAAMC,UAAU0B,UAAY,SAAUL,GAClC,GAAa,OAATlB,KACA,KAAM,IAAIC,WAAU,wDAExB,IAAyB,kBAAdiB,GACP,KAAM,IAAIjB,WAAU,+BAOxB,KAAK,GAFDF,GAHAoB,EAAOhB,OAAOH,MACdK,EAASc,EAAKd,SAAW,EACzBe,EAAUb,UAAU,GAGfc,EAAI,EAAGA,EAAIhB,EAAQgB,IAExB,GADAtB,EAAQoB,EAAKE,GACTH,EAAUI,KAAKF,EAASrB,EAAOsB,EAAGF,GAClC,MAAOE,EAGf,YAYHzB,MAAM4B,OACP5B,MAAM4B,KAAQ,WACV,GAAIC,GAAQtB,OAAON,UAAU6B,SACzBC,EAAa,SAASC,GACtB,MAAqB,kBAAPA,IAAwC,sBAAnBH,EAAMH,KAAKM,IAE9CC,EAAY,SAAS9B,GACrB,GAAI+B,GAASC,OAAOhC,EACpB,OAAIiC,OAAMF,GAAkB,EACb,IAAXA,GAAiBG,SAASH,IACtBA,EAAS,EAAI,MAAUpB,KAAKwB,MAAMxB,KAAKyB,IAAIL,IADHA,GAGhDM,EAAiB1B,KAAK2B,IAAI,EAAG,IAAM,EACnCC,EAAW,SAASvC,GACpB,GAAIK,GAAMyB,EAAU9B,EACpB,OAAOW,MAAKE,IAAIF,KAAKC,IAAIP,EAAK,GAAIgC,GAItC,OAAO,UAAcG,GAEjB,GAAIC,GAAIxC,KAGJyC,EAAQtC,OAAOoC,EAGnB,IAAiB,MAAbA,EACA,KAAM,IAAItC,WAAU,mEAIxB,IACIyC,GADAC,EAAQpC,UAAUF,OAAS,EAAIE,UAAU,GAAK,MAElD,IAAqB,mBAAVoC,GAAuB,CAG9B,IAAKhB,EAAWgB,GACZ,KAAM,IAAI1C,WAAU,oEAIpBM,WAAUF,OAAS,IACnBqC,EAAInC,UAAU,IAiBtB,IAXA,GAUIqC,GAVAxC,EAAMkC,EAASG,EAAMpC,QAKrBwC,EAAIlB,EAAWa,GAAKrC,OAAO,GAAIqC,GAAEpC,IAAQ,GAAIR,OAAMQ,GAGnDK,EAAI,EAGDA,EAAIL,GACPwC,EAASH,EAAMhC,GACXkC,EACAE,EAAEpC,GAAkB,mBAANiC,GAAoBC,EAAMC,EAAQnC,GAAKkC,EAAMrB,KAAKoB,EAAGE,EAAQnC,GAE3EoC,EAAEpC,GAAKmC,EAEXnC,GAAK,CAKT,OAFAoC,GAAExC,OAASD,EAEJyC,OAYS,kBAAjB1C,QAAO2C,SAChB3C,OAAO2C,OAAS,SAASC,GACvB,YACA,IAAc,MAAVA,EACF,KAAM,IAAI9C,WAAU,6CAGtB8C,GAAS5C,OAAO4C,EAChB,KAAK,GAAIC,GAAQ,EAAGA,EAAQzC,UAAUF,OAAQ2C,IAAS,CACrD,GAAIC,GAAS1C,UAAUyC,EACvB,IAAc,MAAVC,EACF,IAAK,GAAIC,KAAOD,GACV9C,OAAON,UAAUsD,eAAe7B,KAAK2B,EAAQC,KAC/CH,EAAOG,GAAOD,EAAOC,IAK7B,MAAOH,KAkBW,mBAAXK,SAA0BA,OAAOC,UAC1CrD,KAAK,oBACHsD,QAAQ,yBAAyB,qBAGpC,SAASC,GACR,YAYA,SAASC,GAAQC,EAAG7C,EAAKD,GACvB,MAAOC,IAAO6C,GAAKA,GAAK9C,EAQ1B,QAAS+C,GAASC,EAAOC,GACvB,MAAOD,GAAME,QAAQD,QASvB,QAASE,GAAaC,GACpB,GAAUhD,SAANgD,EAAiB,QACrB,IAAIA,IAAM5D,OAAO4D,GAAI,MAAOA,EAC5B,MAAM9D,WAAU,4CAOlB,QAAS+D,GAAmBC,GAgB1B,IAZA,GAAIC,GAAIC,OAAOF,GAGXG,EAAIF,EAAE7D,OAGNgB,EAAI,EAGJgD,KAGGhD,EAAI+C,GAAG,CAGZ,GAAIE,GAAIJ,EAAEK,WAAWlD,EAKrB,IAAIiD,EAAI,OAAUA,EAAI,MAEpBD,EAAEG,KAAKF,OAIJ,IAAI,OAAUA,GAAKA,GAAK,MAE3BD,EAAEG,KAAK,WAIJ,IAAI,OAAUF,GAAKA,GAAK,MAG3B,GAAIjD,IAAM+C,EAAI,EACZC,EAAEG,KAAK,WAGJ,CAEH,GAAIC,GAAIP,EAAEK,WAAWlD,EAAI,EAGzB,IAAI,OAAUoD,GAAKA,GAAK,MAAQ,CAE9B,GAAIhB,GAAQ,KAAJa,EAGJI,EAAQ,KAAJD,CAIRJ,GAAEG,KAAK,OAAWf,GAAK,IAAMiB,GAG7BrD,GAAK,MAMLgD,GAAEG,KAAK,OAMbnD,GAAK,EAIP,MAAOgD,GAOT,QAASM,GAAmBC,GAE1B,IAAK,GADDV,GAAI,GACC7C,EAAI,EAAGA,EAAIuD,EAAYvE,SAAUgB,EAAG,CAC3C,GAAIwD,GAAKD,EAAYvD,EACjBwD,IAAM,MACRX,GAAKC,OAAOW,aAAaD,IAEzBA,GAAM,MACNX,GAAKC,OAAOW,cAAcD,GAAM,IAAM,OACP,KAALA,GAAc,QAG5C,MAAOX,GAkBT,QAASa,GAAYtB,GACnB,MAAO,IAAQA,GAAKA,GAAK,IAuB3B,QAASuB,GAAOC,GAEdjF,KAAKiF,UAAYC,MAAM5D,KAAK2D,GAE5BjF,KAAKiF,OAAOE,UA4Ed,QAASC,GAAaC,EAAOC,GAC3B,GAAID,EACF,KAAMpF,WAAU,gBAClB,OAAOqF,IAAkB,MAO3B,QAASC,GAAaC,GACpB,KAAMvF,WAAU,kBAAoBuF,EAAa,0BAInD,QAASC,MAaT,QAASC,MAmBT,QAASC,GAAYC,GAOnB,MALAA,GAAQzB,OAAOyB,GAAOC,OAAOC,cAKzB3F,OAAON,UAAUsD,eAAe7B,KAAKyE,EAAmBH,GACnDG,EAAkBH,GAEpB,KA8eT,QAASI,GAAkBC,EAASjD,GAClC,MAAKA,GACEA,EAAMiD,IAAY,KADN,KAUrB,QAASC,GAAgBV,EAAYxC,GACnC,GAAIiD,GAAUjD,EAAMa,QAAQ2B,EAC5B,OAAOS,QAAiB,KAAOA,EAOjC,QAASjD,GAAMmD,GACb,KAAM,oBAAsB5C,IAC1B,KAAM6C,OAAM,kEAGd,OAAO7C,GAAO,oBAAoB4C,GAQpC,QAASE,GAA+BJ,GAGtC,GAAKA,EAAU,OAASA,EAAU,OAAYA,EAAU,QACtD,MAAO,KAGT,IAAgB,OAAZA,EAAkB,MAAO,MAK7B,IAGI5E,GAHAiF,EAAS,EACTC,EAAoB,EACpBC,EAAMxD,EAAM,UAEhB,KAAK3B,EAAI,EAAGA,EAAImF,EAAInG,SAAUgB,EAAG,CAE/B,GAAIoF,GAAQD,EAAInF,EAChB,MAAIoF,EAAM,IAAMR,GAId,KAHAK,GAASG,EAAM,GACfF,EAAoBE,EAAM,GAQ9B,MAAOF,GAAoBN,EAAUK,EAQvC,QAASI,GAA6BlB,GAEpC,GAAmB,QAAfA,EAAuB,MAAO,KAKlC,IAGInE,GAHAiF,EAAS,EACTK,EAAiB,EACjBH,EAAMxD,EAAM,UAEhB,KAAK3B,EAAI,EAAGA,EAAImF,EAAInG,SAAUgB,EAAG,CAE/B,GAAIoF,GAAQD,EAAInF,EAChB,MAAIoF,EAAM,IAAMjB,GAId,KAHAc,GAASG,EAAM,GACfE,EAAiBF,EAAM,GAQ3B,MAAOE,GAAiBnB,EAAac,EASvC,QAASM,GAAwBpB,GAG/B,GAAIS,GAAUC,EAAgBV,EAAYxC,EAAM,WAChD,OAAgB,QAAZiD,GAAoBzC,EAAQyC,EAAS,KAAM,MACtC,KAGFA,EAST,QAASY,GAAoBrB,GAG3B,GAAIsB,GAAS9D,EAAM,OAKnB,OAAmB,QAAfwC,GAAwC,OAAfA,GACV,OAAfA,GAAwC,OAAfA,GACV,QAAfA,GAAwC,QAAfA,EACpBsB,EAAOC,YAAYvB,GAIrBU,EAAgBV,EAAYsB,GAiBrC,QAASE,GAAYpB,EAAOqB,GAE1B,KAAMjH,eAAgBgH,IACpB,KAAM/G,WAAU,8CAClB2F,GAAkB7E,SAAV6E,EAAsBzB,OAAOyB,GAASsB,EAC9CD,EAAUnD,EAAamD,GAQvBjH,KAAKmH,UAAY,KAEjBnH,KAAKoH,SAAW,KAEhBpH,KAAKqH,YAAa,EAElBrH,KAAKsH,UAAW,EAEhBtH,KAAKuH,YAAc,cAEnBvH,KAAKwH,eAAgB,CAKrB,IAAIC,GAAW9B,EAAYC,EAG3B,IAAiB,OAAb6B,GAAuC,gBAAlBA,EAAStB,KAChC,KAAMuB,YAAW,qBAAuB9B,EAC1C,KAAK+B,EAASF,EAAStB,MACrB,KAAMC,OAAM,sEAKd,IAAIwB,GAAM5H,IAuBV,OApBA4H,GAAIT,UAAYM,EAIZI,QAAQZ,EAAe,SACzBW,EAAIL,YAAc,SAIhBM,QAAQZ,EAAmB,aAC7BW,EAAIP,YAAa,GAGdlH,OAAO2H,iBACV9H,KAAKyH,SAAWG,EAAIT,UAAUhB,KAAKL,cACnC9F,KAAKqF,MAA4B,UAApBuC,EAAIL,YACjBvH,KAAK+H,UAAYH,EAAIP,YAIhBO,EAgKT,QAASI,GAAYpC,EAAOqB,GAE1B,KAAMjH,eAAgBgI,IACpB,KAAM/H,WAAU,8CAClBgH,GAAUnD,EAAamD,GAKvBjH,KAAKmH,UAAY,KAEjBnH,KAAKiI,SAAW,KAIhBjI,KAAKwH,eAAgB,EAErBxH,KAAKkI,OAASL,QAAQZ,EAAe,OAAK,QAAU,aAGpD,IAAIkB,GAAMnI,IAGV,IAAI6H,QAAQZ,EAAyC,iCAAI,CAEvDrB,EAAkB7E,SAAV6E,EAAsBzB,OAAOyB,GAASsB,CAC9C,IAAIO,GAAW9B,EAAYC,EAC3B,IAAiB,OAAb6B,GAAuC,gBAAlBA,EAAStB,KAChC,KAAMuB,YAAW,qBAAuB9B,EAC1C,KAAKwC,EAASX,EAAStB,MACrB,KAAMC,OAAM,sEAGd+B,GAAIhB,UAAYM,MAGhBU,GAAIhB,UAAYxB,EAAY,QAa9B,OAJKxF,QAAO2H,iBACV9H,KAAKyH,SAAWU,EAAIhB,UAAUhB,KAAKL,eAG9BqC,EAoFT,QAASE,GAAYpB,GACnB,GAAI5B,GAAQ4B,EAAQ5B,MAMMiD,EAAkB,EAClBC,EAAkB,EAClBC,EAAoB,EACpBC,EAAsB,IACtBC,EAAsB,GAShD1I,MAAK2I,QAAU,SAASC,EAAQC,GAG9B,GAAIA,IAASC,GAAuC,IAAtBN,EAE5B,MADAA,GAAoB,EACbpD,EAAaC,EAItB,IAAIwD,IAASC,EACX,MAAOC,EAGT,IAA0B,IAAtBP,EAAyB,CAG3B,GAAIhF,EAAQqF,EAAM,EAAM,KAEtB,MAAOA,EAIJ,IAAIrF,EAAQqF,EAAM,IAAM,KAE3BL,EAAoB,EAGpBF,EAAyB,GAAPO,MAIf,IAAIrF,EAAQqF,EAAM,IAAM,KAEd,MAATA,IACFJ,EAAsB,KAEX,MAATI,IACFH,EAAsB,KAExBF,EAAoB,EAEpBF,EAAyB,GAAPO,MAIf,CAAA,IAAIrF,EAAQqF,EAAM,IAAM,KAgB3B,MAAOzD,GAAaC,EAdP,OAATwD,IACFJ,EAAsB,KAEX,MAATI,IACFH,EAAsB,KAExBF,EAAoB,EAEpBF,EAAyB,EAAPO,EAUpB,MAAO,MAKT,IAAKrF,EAAQqF,EAAMJ,EAAqBC,GAatC,MARAJ,GAAkBE,EAAoBD,EAAkB,EACxDE,EAAsB,IACtBC,EAAsB,IAGtBE,EAAOI,QAAQH,GAGRzD,EAAaC,EAiBtB,IAZAoD,EAAsB,IACtBC,EAAsB,IAItBJ,EAAmBA,GAAmB,EAAa,GAAPO,EAG5CN,GAAmB,EAIfA,IAAoBC,EACtB,MAAO,KAGT,IAAIhD,GAAa8C,CAOjB,OAHAA,GAAkBE,EAAoBD,EAAkB,EAGjD/C,GAUX,QAASyD,GAAYhC,GACPA,EAAQ5B,KAMpBrF,MAAK2I,QAAU,SAASC,EAAQpD,GAE9B,GAAIA,IAAesD,EACjB,MAAOC,EAIT,IAAIvF,EAAQgC,EAAY,EAAQ,KAC9B,MAAOA,EAGT,IAAI0D,GAAO5C,CAEP9C,GAAQgC,EAAY,IAAQ,OAE9B0D,EAAQ,EACR5C,EAAS,KAGF9C,EAAQgC,EAAY,KAAQ,QAEnC0D,EAAQ,EACR5C,EAAS,KAGF9C,EAAQgC,EAAY,MAAS,WAEpC0D,EAAQ,EACR5C,EAAS,IAQX,KAHA,GAAI6C,KAAU3D,GAAe,EAAI0D,GAAU5C,GAGpC4C,EAAQ,GAAG,CAGhB,GAAIE,GAAO5D,GAAe,GAAK0D,EAAQ,EAGvCC,GAAM3E,KAAK,IAAe,GAAP4E,GAGnBF,GAAS,EAIX,MAAOC,IAwBX,QAASE,GAAkBrG,EAAOiE,GAChC,GAAI5B,GAAQ4B,EAAQ5B,KAQpBrF,MAAK2I,QAAU,SAASC,EAAQC,GAE9B,GAAIA,IAASC,EACX,MAAOC,EAIT,IAAIhE,EAAY8D,GACd,MAAOA,EAIT,IAAIrD,GAAaxC,EAAM6F,EAAO,IAG9B,OAAmB,QAAfrD,EACKJ,EAAaC,GAGfG,GAWX,QAAS8D,GAAkBtG,EAAOiE,GACpBA,EAAQ5B,KAMpBrF,MAAK2I,QAAU,SAASC,EAAQpD,GAE9B,GAAIA,IAAesD,EACjB,MAAOC,EAIT,IAAIQ,EAAiB/D,GACnB,MAAOA,EAIT,IAAIS,GAAUC,EAAgBV,EAAYxC,EAO1C,OAJgB,QAAZiD,GACFV,EAAaC,GAGRS,EAAU,KAqDrB,QAASuD,GAAevC,GACtB,GAAI5B,GAAQ4B,EAAQ5B,MAGMoE,EAAgB,EAChBC,EAAiB,EACjBC,EAAgB,CAQ1C3J,MAAK2I,QAAU,SAASC,EAAQC,GAG9B,GAAIA,IAASC,GAAmC,IAAlBW,GACP,IAAnBC,GAA6C,IAAlBC,EAC7B,MAAOZ,EAKLF,KAASC,GACU,IAAlBW,GAA6C,IAAnBC,GACR,IAAlBC,IACHF,EAAgB,EAChBC,EAAiB,EACjBC,EAAgB,EAChBvE,EAAaC,GAEf,IAAIG,EAEJ,IAAsB,IAAlBmE,EAAwB,CAE1BnE,EAAa,KAKThC,EAAQqF,EAAM,GAAM,MACtBrD,EAAaa,EAEkB,IADgC,KAAhC,IAAxBoD,EAAgB,MAAcC,EAAiB,MAChDC,EAAgB,MAAcd,EAAO,IAK7C,IAAIe,IAAUF,EAAgBC,EAAed,EAU7C,OANAY,GAAgB,EAChBC,EAAiB,EACjBC,EAAgB,EAIG,OAAfnE,GACFoD,EAAOI,QAAQY,GACRxE,EAAaC,IAIfG,EAIT,GAAuB,IAAnBkE,EAIF,MAAIlG,GAAQqF,EAAM,IAAM,MACtBc,EAAgBd,EACT,OAKTD,EAAOI,SAASU,EAAgBb,IAChCY,EAAgB,EAChBC,EAAiB,EACVtE,EAAaC,GAItB,IAAsB,IAAlBoE,EAAwB,CAI1B,GAAIjG,EAAQqF,EAAM,GAAM,IAEtB,MADAa,GAAiBb,EACV,IAKT,IAAIgB,GAAOJ,EACPxD,EAAU,IACdwD,GAAgB,CAIhB,IAAInD,GAASuC,EAAO,IAAO,GAAO,EAkBlC,QAdIrF,EAAQqF,EAAM,GAAM,MAASrF,EAAQqF,EAAM,IAAM,QACnD5C,EAA0B,KAAf4D,EAAO,MAAehB,EAAOvC,IAI1Cd,EAAyB,OAAZS,EAAmB,KAC5BD,EAAkBC,EAASjD,EAAM,YAIlB,OAAfwC,GAAuBT,EAAY8D,IACrCD,EAAOI,QAAQH,GAGE,OAAfrD,EACKJ,EAAaC,GAGfG,EAKT,MAAIT,GAAY8D,GACPA,EAGI,MAATA,EACK,KAILrF,EAAQqF,EAAM,IAAM,MACtBY,EAAgBZ,EACT,MAIFzD,EAAaC,IAWxB,QAASyE,GAAe7C,EAAS8C,GACnB9C,EAAQ5B,KAOpBrF,MAAK2I,QAAU,SAASC,EAAQpD,GAE9B,GAAIA,IAAesD,EACjB,MAAOC,EAIT,IAAIQ,EAAiB/D,GACnB,MAAOA,EAGT,IAAmB,QAAfA,EACF,MAAOD,GAAaC,EAItB,IAAIuE,GAA2B,OAAfvE,EACd,MAAO,IAIT,IAAIS,GAAUC,EAAgBV,EAAYxC,EAAM,WAGhD,IAAgB,OAAZiD,EAAkB,CAGpB,GAAI4D,GAAO3H,EAAM+D,EAAU,KAAO,IAG9B+D,EAAQ/D,EAAU,IAGlBK,EAAS0D,EAAQ,GAAO,GAAO,EAGnC,QAAQH,EAAMG,EAAQ1D,GAIxB,GAAIyD,EACF,MAAOxE,GAAaC,EAItBS,GAAUS,EAA6BlB,EAGvC,IAAIyE,GAAQ/H,EAAM+D,EAAU,GAAK,IAAM,GAGvCA,IAA4B,GAARgE,EAAa,IAAM,EAGvC,IAAIC,GAAQhI,EAAM+D,EAAU,GAAK,IAGjCA,IAA4B,GAARiE,EAAa,GAGjC,IAAIC,GAAQjI,EAAM+D,EAAU,IAGxBmE,EAAQnE,EAAkB,GAARkE,CAItB,QAAQF,EAAQ,IACRC,EAAQ,GACRC,EAAQ,IACRC,EAAQ,KA0BpB,QAASC,GAAYpD,GACnB,GAAI5B,GAAQ4B,EAAQ5B,MAEMiF,EAAY,CAStCtK,MAAK2I,QAAU,SAASC,EAAQC,GAG9B,GAAIA,IAASC,GAA+B,IAAdwB,EAE5B,MADAA,GAAY,EACLlF,EAAaC,EAKtB,IAAIwD,IAASC,GAA+B,IAAdwB,EAC5B,MAAOvB,EAKT,IAAkB,IAAduB,EAAoB,CACtB,GAAIT,GAAOS,EACPrE,EAAU,IACdqE,GAAY,CAIZ,IAAIhE,GAASuC,EAAO,IAAO,GAAO,EAgBlC,SAZIrF,EAAQqF,EAAM,GAAM,MAASrF,EAAQqF,EAAM,IAAM,QACnD5C,EAA0B,KAAf4D,EAAO,MAAehB,EAAOvC,IAWlCL,GACN,IAAK,MAAM,OAAQ,IAAQ,IAC3B,KAAK,MAAM,OAAQ,IAAQ,IAC3B,KAAK,MAAM,OAAQ,IAAQ,IAC3B,KAAK,MAAM,OAAQ,IAAQ,KAK7B,GAAIT,GAA0B,OAAZS,EAAoB,KAClCD,EAAkBC,EAASjD,EAAM,QAQrC,OAJmB,QAAfwC,GAAuBT,EAAY8D,IACrCD,EAAOI,QAAQH,GAGE,OAAfrD,EACKJ,EAAaC,GAGfG,EAKT,MAAIT,GAAY8D,GACPA,EAILrF,EAAQqF,EAAM,IAAM,MACtByB,EAAYzB,EACL,MAIFzD,EAAaC,IAUxB,QAASkF,GAAYtD,GACPA,EAAQ5B,KAMpBrF,MAAK2I,QAAU,SAASC,EAAQpD,GAE9B,GAAIA,IAAesD,EACjB,MAAOC,EAIT,IAAIQ,EAAiB/D,GACnB,MAAOA,EAGT,IAAIS,GAAUY,EAAoBrB,EAGlC,IAAgB,OAAZS,EACF,MAAOV,GAAaC,EAGtB,IAAIqE,GAAO3H,EAAM+D,EAAU,KAAO,GAGlC,IAAI4D,EAAO,IACT,MAAOtE,GAAaC,EAGtB,IAAIwE,GAAQ/D,EAAU,IAIlBK,EAAS0D,EAAQ,GAAO,GAAO,EAGnC,QAAQH,EAAMG,EAAQ1D,IA0B1B,QAASkE,GAAavD,GACpB,GAAI5B,GAAQ4B,EAAQ5B,MAIOoF,GAAqB,EACtBC,EAAa,CASvC1K,MAAK2I,QAAU,SAASC,EAAQC,GAG9B,GAAIA,IAASC,GAAgC,IAAf4B,EAE5B,MADAA,GAAa,EACNtF,EAAaC,EAKtB,IAAIwD,IAASC,GAAgC,IAAf4B,EAC5B,MAAO3B,EAKT,IAAmB,MAAf2B,GAAuBlH,EAAQqF,EAAM,IAAM,KAE7C,MADA6B,GAAa,EACN,MAAS7B,EAAO,GAMzB,IAAmB,MAAf6B,GAAuBlH,EAAQqF,EAAM,IAAM,KAG7C,MAFA4B,IAAqB,EACrBC,EAAa7B,EACN,IAKT,IAAmB,IAAf6B,EAAqB,CACvB,GAAIb,GAAOa,CACXA,GAAa,CAGb,IAAIlF,GAAa,IAqBjB,OAfIhC,GAAQqG,EAAM,IAAM,MAASrG,EAAQqF,EAAM,IAAM,OACnDrD,EAAaQ,EACK,IAAf6D,EAAO,MAAchB,EAAO,KAC7B7F,EAAOyH,EAAiC,UAAZ,aAIhCA,GAAqB,EAIhBjH,EAAQqF,EAAM,IAAM,MACvBD,EAAOI,QAAQH,GAGE,OAAfrD,EACKJ,EAAaC,GAGfG,EAKT,MAAIT,GAAY8D,GACPA,EAII,MAATA,GAA0B,MAATA,GAAiBrF,EAAQqF,EAAM,IAAM,MACxD6B,EAAa7B,EACN,MAIFzD,EAAaC,IAUxB,QAASsF,GAAa1D,GACRA,EAAQ5B,KAMpBrF,MAAK2I,QAAU,SAASC,EAAQpD,GAE9B,GAAIA,IAAesD,EACjB,MAAOC,EAIT,IAAIQ,EAAiB/D,GACnB,MAAOA,EAGT,IAAmB,MAAfA,EACF,MAAO,GAGT,IAAmB,OAAfA,EACF,MAAO,IAIT,IAAIhC,EAAQgC,EAAY,MAAQ,OAC9B,OAAQ,IAAMA,EAAa,MAAS,IAGnB,QAAfA,IACFA,EAAa,MAIf,IAAIS,GAAUC,EAAgBV,EAAYxC,EAAM,WAGhD,IAAgB,OAAZiD,EACF,MAAOV,GAAaC,EAGtB,IAAIqE,GAAO3H,EAAM+D,EAAU,IAAM,IAG7B+D,EAAQ/D,EAAU,GAAK,GAG3B,QAAQ4D,EAAMG,IAqBlB,QAASY,GAAiB3D,GACxB,GAAI5B,GAAQ4B,EAAQ5B,MAEhBwF,GACFC,MAAO,EACPC,MAAO,EACPC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,YAAa,EACbC,OAAQ,GAMgBC,EAA0BR,EAAOC,MACjCQ,EAAiCT,EAAOC,MACxCS,EAAiB,EAChBC,GAAwB,CAQnDxL,MAAK2I,QAAU,SAASC,EAAQC,GAE9B,OAAQwC,GACR,QACA,IAAKR,GAAOC,MAKV,MAAa,MAATjC,GAGFwC,EAA0BR,EAAOM,YAC1B,MAIL3H,EAAQqF,EAAM,EAAM,MAAkB,KAATA,GACjB,KAATA,GAA0B,KAATA,GAGtB2C,GAAwB,EACjB3C,GAILA,IAASC,EAEJC,GAKTyC,GAAwB,EACjBpG,EAAaC,GAEtB,KAAKwF,GAAOE,MAKV,MAAa,MAATlC,GAGFwC,EAA0BR,EAAOM,YAC1B,MAII,KAATtC,GAGF2C,GAAwB,EACjB,KAII,MAAT3C,GAGF2C,GAAwB,EACjB,MAILhI,EAAQqF,EAAM,EAAM,MAAkB,KAATA,GAA0B,KAATA,GAClC,KAATA,GAA0B,KAATA,GAA0B,MAATA,GAGvC2C,GAAwB,EACjB3C,GAILA,IAASC,EAEJC,GAKTyC,GAAwB,EACjBpG,EAAaC,GAEtB,KAAKwF,GAAOG,SAKV,MAAa,MAATnC,GAGFwC,EAA0BR,EAAOM,YAC1B,MAIL3H,EAAQqF,EAAM,GAAM,KAGtB2C,GAAwB,EACjB,MAAS3C,EAAO,IAIrBA,IAASC,EAEJC,GAKTyC,GAAwB,EACjBpG,EAAaC,GAEtB,KAAKwF,GAAOI,SAKV,MAAa,MAATpC,GAGFwC,EAA0BR,EAAOM,YAC1B,MAIL3H,EAAQqF,EAAM,GAAM,MAItB2C,GAAwB,EACxBD,EAAiB1C,EACjBwC,EAA0BR,EAAOK,UAC1B,MAILrC,IAASC,EAEJC,GAKTyC,GAAwB,EACjBpG,EAAaC,GAEtB,KAAKwF,GAAOK,UAKV,GAAa,KAATrC,EAIF,MADAwC,GAA0BR,EAAOM,YAC1B/F,EAAaC,EAItB,IAAI7B,EAAQqF,EAAM,GAAM,KAAO,CAE7BwC,EAA0BR,EAAOI,QAGjC,IAAIhF,GAAoC,IAAzBsF,EAAiB,IAAa1C,EAAO,GAIhDrD,EAAaQ,EAAkBC,EAASjD,EAAM,WAGlD,OAAmB,QAAfwC,EACKJ,EAAaC,GAGfG,EAIT,MAAIqD,KAASC,GAGXuC,EAA0BR,EAAOI,SACjCrC,EAAOI,QAAQH,GACRzD,EAAaC,KAMtBgG,EAA0BR,EAAOI,SAC1B7F,EAAaC,GAEtB,KAAKwF,GAAOM,YAMV,MAAa,MAATtC,GAA0B,KAATA,GACnB0C,EAAiB1C,EACjBwC,EAA0BR,EAAOO,OAC1B,OAITxC,EAAOI,QAAQH,GAKf2C,GAAwB,EACxBH,EAA0BC,EACnBlG,EAAaC,GAEtB,KAAKwF,GAAOO,OAKV,GAAIvB,GAAO0B,CACXA,GAAiB,CAGjB,IAAIE,GAAQ,IAoBZ,IAjBa,KAAT5B,GAA0B,KAAThB,IACnB4C,EAAQZ,EAAOC,OAGJ,KAATjB,GAA0B,KAAThB,IACnB4C,EAAQZ,EAAOE,OAGJ,KAATlB,GAA0B,KAAThB,IACnB4C,EAAQZ,EAAOG,UAIJ,KAATnB,GAA2B,KAAThB,GAA0B,KAATA,IACrC4C,EAAQZ,EAAOI,UAGH,OAAVQ,EAAgB,CAGlBJ,EAA0BA,EAA0BI,CAGpD,IAAIC,GAAcF,CAOlB,OAJAA,IAAwB,EAIhBE,EAAqBtG,EAAaC,GAApB,KAWxB,MAPAuD,GAAOI,SAASa,EAAMhB,IAKtB2C,GAAwB,EACxBH,EAA0BC,EACnBlG,EAAaC,KAW1B,QAASsG,GAAiB1E,GACxB,GAKI4D,IALQ5D,EAAQ5B,OAMlByF,MAAO,EACPC,MAAO,EACPa,QAAS,IAEeC,EAAkBhB,EAAOC,KAMnD9K,MAAK2I,QAAU,SAASC,EAAQpD,GAK9B,GAAIA,IAAesD,GACf+C,IAAoBhB,EAAOC,MAG7B,MAFAlC,GAAOI,QAAQxD,GACfqG,EAAkBhB,EAAOC,OACjB,GAAM,GAAM,GAKtB,IAAItF,IAAesD,GAAiB+C,IAAoBhB,EAAOC,MAC7D,MAAO/B,EAIT,MAAK8C,IAAoBhB,EAAOC,OAC3Be,IAAoBhB,EAAOE,OACZ,KAAfvF,GAAwC,KAAfA,GACV,KAAfA,GACH,MAAOD,GAAa,MAKtB,IAAIsG,IAAoBhB,EAAOC,OAC3BvB,EAAiB/D,GACnB,MAAOA,EAKT,IAAIqG,IAAoBhB,EAAOE,QACzBxB,EAAiB/D,IACH,KAAfA,GAAwC,MAAfA,GACX,KAAdA,GAAsC,MAAdA,GAAwB,CAInD,GAAI+D,EAAiB/D,GACnB,MAAOA,EAGT,IAAmB,MAAfA,EACF,MAAO,GAGT,IAAmB,OAAfA,EACF,MAAO,KAOX,GAAI+D,EAAiB/D,IACjBqG,IAAoBhB,EAAOC,MAG7B,MAFAlC,GAAOI,QAAQxD,GACfqG,EAAkBhB,EAAOC,OACjB,GAAM,GAAM,GAOtB,KAAoB,MAAftF,GAAwC,OAAfA,IAC1BqG,IAAoBhB,EAAOE,MAG7B,MAFAnC,GAAOI,QAAQxD,GACfqG,EAAkBhB,EAAOE,OACjB,GAAM,GAAM,GAIH,QAAfvF,IACFA,EAAa,MAIf,IAAIS,GAAUC,EAAgBV,EAAYxC,EAAM,WAGhD,IAAgB,OAAZiD,EACF,MAAOV,GAAaC,EAKtB,IAAIqG,IAAoBhB,EAAOe,QAG7B,MAFAhD,GAAOI,QAAQxD,GACfqG,EAAkBhB,EAAOe,SACjB,GAAM,GAAM,GAItB,IAAI/B,GAAO3H,EAAM+D,EAAU,IAAM,GAG7B+D,EAAQ/D,EAAU,GAAK,EAG3B,QAAQ4D,EAAMG,IAqBlB,QAAS8B,GAAgB7E,GACvB,GAAI5B,GAAQ4B,EAAQ5B,MAGM0G,EAAgB,CAQ1C/L,MAAK2I,QAAU,SAASC,EAAQC,GAG9B,GAAIA,IAASC,GAAmC,IAAlBiD,EAE5B,MADAA,GAAgB,EACT3G,EAAaC,EAKtB,IAAIwD,IAASC,GAAmC,IAAlBiD,EAC5B,MAAOhD,EAKT,IAAsB,IAAlBgD,EAAwB,CAC1B,GAAIlC,GAAOkC,EACP9F,EAAU,IACd8F,GAAgB,CAIhB,IAAIzF,GAAUuC,EAAO,IAAQ,GAAO,GAIhCmD,EAAenC,EAAO,IAAQ,IAAO,KAIrCrG,EAAQqF,EAAM,GAAM,MAASrF,EAAQqF,EAAM,IAAM,QACnD5C,EAAiC,KAAtB4D,EAAOmC,GAAqBnD,EAAOvC,EAIhD,IAAId,GAA0B,OAAZS,EAAoB,KAChCD,EAAkBC,EAASjD,EAAM,WAKvC,OAAmB,QAAfwC,GAAmC,OAAZS,GACvBzC,EAAQyC,EAAS,KAAM,OAClB,MAASA,EAAU,MAIT,OAAfT,GAAuBT,EAAY8D,IACrCD,EAAOI,QAAQH,GAGE,OAAfrD,EACKJ,EAAaC,GAGfG,GAKT,MAAIT,GAAY8D,IAAkB,MAATA,EAChBA,EAILrF,EAAQqF,EAAM,IAAM,KACf,MAASA,EAAO,IAIrBrF,EAAQqF,EAAM,IAAM,MAASrF,EAAQqF,EAAM,IAAM,MACnDkD,EAAgBlD,EACT,MAIFzD,EAAaC,IAUxB,QAAS4G,GAAgBhF,GACXA,EAAQ5B,KAMpBrF,MAAK2I,QAAU,SAASC,EAAQpD,GAE9B,GAAIA,IAAesD,EACjB,MAAOC,EAIT,IAAIQ,EAAiB/D,IAA8B,MAAfA,EAClC,MAAOA,EAGT,IAAmB,MAAfA,EACF,MAAO,GAGT,IAAmB,OAAfA,EACF,MAAO,IAIT,IAAIhC,EAAQgC,EAAY,MAAQ,OAC9B,MAAOA,GAAa,MAAS,GAGZ,QAAfA,IACFA,EAAa,MAGf,IAAIS,GAAUW,EAAwBpB,EAGtC,IAAgB,OAAZS,EACF,MAAOV,GAAaC,EAGtB,IAAIqE,GAAO3H,EAAM+D,EAAU,KAIvB+F,EAAenC,EAAO,GAAQ,IAAO,IAGrCG,EAAQ/D,EAAU,IAIlBK,EAAU0D,EAAQ,GAAQ,GAAO,EAIrC,QAAQH,EAAOmC,EAAahC,EAAQ1D,IAyBxC,QAAS4F,GAAajF,GACpB,GAAI5B,GAAQ4B,EAAQ5B,MAGM8G,EAAa,CAQvCnM,MAAK2I,QAAU,SAASC,EAAQC,GAG9B,GAAIA,IAASC,GAAgC,IAAfqD,EAE5B,MADAA,GAAa,EACN/G,EAAaC,EAKtB,IAAIwD,IAASC,GAAgC,IAAfqD,EAC5B,MAAOpD,EAKT,IAAmB,IAAfoD,EAAqB,CACvB,GAAItC,GAAOsC,EACPlG,EAAU,IACdkG,GAAa,EAIT3I,EAAQqF,EAAM,GAAM,OACtB5C,EAA0B,KAAf4D,EAAO,MAAehB,EAAO,IAI1C,IAAIrD,GAA0B,OAAZS,EACV,KAAOD,EAAkBC,EAASjD,EAAM,UAQhD,OAJgB,QAAZiD,GAAoBlB,EAAY8D,IAClCD,EAAOI,QAAQH,GAGE,OAAfrD,EACKJ,EAAaC,GAGfG,EAKT,MAAIT,GAAY8D,GACPA,EAILrF,EAAQqF,EAAM,IAAM,MACtBsD,EAAatD,EACN,MAIFzD,EAAaC,IAUxB,QAAS+G,GAAanF,GACRA,EAAQ5B,KAMpBrF,MAAK2I,QAAU,SAASC,EAAQpD,GAE9B,GAAIA,IAAesD,EACjB,MAAOC,EAIT,IAAIQ,EAAiB/D,GACnB,MAAOA,EAIT,IAAIS,GAAUC,EAAgBV,EAAYxC,EAAM,UAGhD,IAAgB,OAAZiD,EACF,MAAOV,GAAaC,EAGtB,IAAIqE,GAAO3H,EAAM+D,EAAU,KAAO,IAG9B+D,EAAS/D,EAAU,IAAO,EAG9B,QAAQ4D,EAAMG,IA6BlB,QAASqC,GAAuBC,EAAWC,GAEzC,GAAItC,GAAQqC,GAAa,EAGrBpC,EAAoB,IAAZoC,CAIZ,OAAIC,IACMtC,EAAOC,IAETA,EAAOD,GAUjB,QAASuC,GAAaC,EAAUxF,GAC9B,GAAI5B,GAAQ4B,EAAQ5B,MACOqH,EAAkB,KAClBC,EAAuB,IAQlD3M,MAAK2I,QAAU,SAASC,EAAQC,GAI9B,GAAIA,IAASC,IAAsC,OAApB4D,GACoB,OAAzBC,GACxB,MAAOvH,GAAaC,EAKtB,IAAIwD,IAASC,GAAqC,OAApB4D,GACD,OAAzBC,EACF,MAAO5D,EAKT,IAAwB,OAApB2D,EAEF,MADAA,GAAkB7D,EACX,IAIT,IAAIyD,EAgBJ,IAZEA,EAHEG,GAGWC,GAAmB,GAAK7D,GAIxBA,GAAQ,GAAK6D,EAG5BA,EAAkB,KAKW,OAAzBC,EAA+B,CACjC,GAAIC,GAAiBD,CAMrB,OALAA,GAAuB,KAKnBnJ,EAAQ8I,EAAW,MAAQ,OACtB,MAAsC,MAA3BM,EAAiB,QAC9BN,EAAY,QAMnB1D,EAAOI,QAAQqD,EAAuBC,EAAWG,IAC1CrH,EAAaC,IAKtB,MAAI7B,GAAQ8I,EAAW,MAAQ,QAC7BK,EAAuBL,EAChB,MAKL9I,EAAQ8I,EAAW,MAAQ,OACtBlH,EAAaC,GAGfiH,GAWX,QAASO,GAAaJ,EAAUxF,GAClBA,EAAQ5B,KAMpBrF,MAAK2I,QAAU,SAASC,EAAQpD,GAE9B,GAAIA,IAAesD,EACjB,MAAOC,EAKT,IAAIvF,EAAQgC,EAAY,EAAQ,OAC9B,MAAO6G,GAAuB7G,EAAYiH,EAI5C,IAAI5C,GAAOwC,GACP7G,EAAa,OAAY,IAAM,MAAQiH,GAIvCzC,EAAQqC,GACR7G,EAAa,MAAW,MAAS,MAAQiH,EAG7C,OAAO5C,GAAKiD,OAAO9C,IAoCvB,QAAS+C,GAAoB9F,GACfA,EAAQ5B,KAQpBrF,MAAK2I,QAAU,SAASC,EAAQC,GAE9B,MAAIA,KAASC,EACJC,EAILhE,EAAY8D,GACPA,EAGF,MAASA,EAAO,KAU3B,QAASmE,GAAoB/F,GACfA,EAAQ5B,KAMpBrF,MAAK2I,QAAU,SAASC,EAAQpD,GAE9B,MAAIA,KAAesD,EACVC,EAILQ,EAAiB/D,GACZA,EAILhC,EAAQgC,EAAY,MAAQ,OACvBA,EAAa,MAAS,IAGxBD,EAAaC,IAlqGxB,GAAItD,GAAQxB,KAAKwB,MAyIbqH,EAAmBxE,EAOf+D,IAgBR9D,GAAOnF,WAILoN,YAAa,WACX,OAAQjN,KAAKiF,OAAO5E,QAWrB6M,KAAM,WACL,MAAKlN,MAAKiF,OAAO5E,OAETL,KAAKiF,OAAOkI,MADXrE,GAYXE,QAAS,SAASoE,GAChB,GAAIxN,MAAMyN,QAAQD,GAEhB,IADA,GAAInI,GAAqC,EAClCA,EAAO5E,QACZL,KAAKiF,OAAOT,KAAKS,EAAOkI,WAE1BnN,MAAKiF,OAAOT,KAAK4I,IAYrB5I,KAAM,SAAS4I,GACb,GAAIxN,MAAMyN,QAAQD,GAEhB,IADA,GAAInI,GAAqC,EAClCA,EAAO5E,QACZL,KAAKiF,OAAOqI,QAAQrI,EAAOsI,aAE7BvN,MAAKiF,OAAOqI,QAAQF,IAY1B,IAAIrE,KAuBJtD,GAAQ5F,WAQN8I,QAAS,SAASC,EAAQC,MAK5BnD,EAAQ7F,WAMN8I,QAAS,SAASC,EAAQpD,KAiC5B,IAAIgI,KAEAA,YAEIC,QACE,oBACA,QACA,QAEFtH,KAAQ,UAGZuH,QAAW,iBAGXF,YAEIC,QACE,MACA,QACA,WACA,UAEFtH,KAAQ,WAGRsH,QACE,cACA,aACA,aACA,YACA,WACA,aACA,kBACA,KACA,UAEFtH,KAAQ,eAGRsH,QACE,cACA,aACA,aACA,YACA,WACA,aACA,kBACA,KACA,UAEFtH,KAAQ,eAGRsH,QACE,cACA,aACA,aACA,YACA,WACA,aACA,kBACA,KACA,UAEFtH,KAAQ,eAGRsH,QACE,qBACA,WACA,aACA,aACA,YACA,WACA,aACA,mBAEFtH,KAAQ,eAGRsH,QACE,SACA,WACA,cACA,cACA,mBACA,WACA,aACA,eACA,eACA,aACA,YACA,WACA,aACA,mBAEFtH,KAAQ,eAGRsH,QACE,kBACA,WACA,WACA,QACA,SACA,aACA,aACA,YACA,WACA,aACA,kBACA,gBAEFtH,KAAQ,eAGRsH,QACE,cACA,mBACA,SACA,aACA,eACA,aACA,YACA,WACA,aACA,kBACA,UAEFtH,KAAQ,eAGRsH,QACE,cACA,eACA,WAEFtH,KAAQ,iBAGRsH,QACE,cACA,cACA,aACA,aACA,YACA,KACA,UAEFtH,KAAQ,gBAGRsH,QACE,cACA,aACA,aAEFtH,KAAQ,gBAGRsH,QACE,cACA,aACA,aAEFtH,KAAQ,gBAGRsH,QACE,cACA,cACA,aACA,YACA,cACA,MAEFtH,KAAQ,gBAGRsH,QACE,eAEFtH,KAAQ,gBAGRsH,QACE,UACA,MACA,OACA,SACA,UAEFtH,KAAQ,WAGRsH,QACE,UACA,UAEFtH,KAAQ,WAGRsH,QACE,cACA,MACA,YACA,eAEFtH,KAAQ,cAGRsH,QACE,UACA,cACA,aACA,YACA,UACA,eAEFtH,KAAQ,gBAGRsH,QACE,SACA,eACA,YAEFtH,KAAQ,iBAGRsH,QACE,SACA,eACA,YAEFtH,KAAQ,iBAGRsH,QACE,iBACA,QACA,SACA,QACA,cACA,SACA,aACA,aACA,YACA,WACA,aACA,kBACA,KACA,SACA,WACA,eACA,YAEFtH,KAAQ,iBAGRsH,QACE,SACA,eACA,YAEFtH,KAAQ,iBAGRsH,QACE,SACA,cACA,aACA,aACA,YACA,WACA,aACA,kBACA,KACA,SACA,eACA,YAEFtH,KAAQ,iBAGRsH,QACE,SACA,eACA,YAEFtH,KAAQ,iBAGRsH,QACE,SACA,eACA,YAEFtH,KAAQ,iBAGRsH,QACE,SACA,eACA,YAEFtH,KAAQ,iBAGRsH,QACE,SACA,eACA,YAEFtH,KAAQ,iBAGRsH,QACE,iBACA,mBAEFtH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","file":"../ie-polyfills.js","sourcesContent":["// jshint freeze:false\r\n// jshint bitwise: false\r\nif (!Array.prototype.fill) {\r\n    Array.prototype.fill = function (value) {\r\n\r\n        // Steps 1-2.\r\n        if (this == null) {\r\n            throw new TypeError('this is null or not defined');\r\n        }\r\n\r\n        var O = Object(this);\r\n\r\n        // Steps 3-5.\r\n        var len = O.length >>> 0;\r\n\r\n        // Steps 6-7.\r\n        var start = arguments[1];\r\n        var relativeStart = start >> 0;\r\n\r\n        // Step 8.\r\n        var k = relativeStart < 0 ?\r\n            Math.max(len + relativeStart, 0) :\r\n            Math.min(relativeStart, len);\r\n\r\n        // Steps 9-10.\r\n        var end = arguments[2];\r\n        var relativeEnd = end === undefined ?\r\n            len : end >> 0;\r\n\r\n        // Step 11.\r\n        var final = relativeEnd < 0 ?\r\n            Math.max(len + relativeEnd, 0) :\r\n            Math.min(relativeEnd, len);\r\n\r\n        // Step 12.\r\n        while (k < final) {\r\n            O[k] = value;\r\n            k++;\r\n        }\r\n\r\n        // Step 13.\r\n        return O;\r\n    };\r\n}\r\n// jshint freeze:true\r\n// jshint bitwise: false\r\n\n// jshint freeze:false\r\n// jshint bitwise: false\r\nif (!Array.prototype.find) {\r\n    Array.prototype.find = function (predicate) {\r\n        if (this === null) {\r\n            throw new TypeError('Array.prototype.find called on null or undefined');\r\n        }\r\n        if (typeof predicate !== 'function') {\r\n            throw new TypeError('predicate must be a function');\r\n        }\r\n        var list = Object(this);\r\n        var length = list.length >>> 0;\r\n        var thisArg = arguments[1];\r\n        var value;\r\n\r\n        for (var i = 0; i < length; i++) {\r\n            value = list[i];\r\n            if (predicate.call(thisArg, value, i, list)) {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n}\r\n\r\n// jshint freeze:true\r\n// jshint bitwise: false\r\n\n// jshint freeze:false\r\n// jshint bitwise: false\r\nif (!Array.prototype.findIndex) {\r\n    Array.prototype.findIndex = function (predicate) {\r\n        if (this === null) {\r\n            throw new TypeError('Array.prototype.findIndex called on null or undefined');\r\n        }\r\n        if (typeof predicate !== 'function') {\r\n            throw new TypeError('predicate must be a function');\r\n        }\r\n        var list = Object(this);\r\n        var length = list.length >>> 0;\r\n        var thisArg = arguments[1];\r\n        var value;\r\n\r\n        for (var i = 0; i < length; i++) {\r\n            value = list[i];\r\n            if (predicate.call(thisArg, value, i, list)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n}\r\n\r\n// jshint freeze:true\r\n// jshint bitwise: false\r\n\n// Production steps of ECMA-262, Edition 6, 22.1.2.1\r\n// Reference: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.from\r\n\r\n// jscs:disable\r\n/* jshint ignore:start */\r\nif (!Array.from) {\r\n    Array.from = (function() {\r\n        var toStr = Object.prototype.toString;\r\n        var isCallable = function(fn) {\r\n            return typeof fn === 'function' || toStr.call(fn) === '[object Function]';\r\n        };\r\n        var toInteger = function(value) {\r\n            var number = Number(value);\r\n            if (isNaN(number)) { return 0; }\r\n            if (number === 0 || !isFinite(number)) { return number; }\r\n            return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\r\n        };\r\n        var maxSafeInteger = Math.pow(2, 53) - 1;\r\n        var toLength = function(value) {\r\n            var len = toInteger(value);\r\n            return Math.min(Math.max(len, 0), maxSafeInteger);\r\n        };\r\n\r\n        // The length property of the from method is 1.\r\n        return function from(arrayLike/*, mapFn, thisArg */) {\r\n            // 1. Let C be the this value.\r\n            var C = this;\r\n\r\n            // 2. Let items be ToObject(arrayLike).\r\n            var items = Object(arrayLike);\r\n\r\n            // 3. ReturnIfAbrupt(items).\r\n            if (arrayLike == null) {\r\n                throw new TypeError(\"Array.from requires an array-like object - not null or undefined\");\r\n            }\r\n\r\n            // 4. If mapfn is undefined, then let mapping be false.\r\n            var mapFn = arguments.length > 1 ? arguments[1] : void undefined;\r\n            var T;\r\n            if (typeof mapFn !== 'undefined') {\r\n                // 5. else\r\n                // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\r\n                if (!isCallable(mapFn)) {\r\n                    throw new TypeError('Array.from: when provided, the second argument must be a function');\r\n                }\r\n\r\n                // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\r\n                if (arguments.length > 2) {\r\n                    T = arguments[2];\r\n                }\r\n            }\r\n\r\n            // 10. Let lenValue be Get(items, \"length\").\r\n            // 11. Let len be ToLength(lenValue).\r\n            var len = toLength(items.length);\r\n\r\n            // 13. If IsConstructor(C) is true, then\r\n            // 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.\r\n            // 14. a. Else, Let A be ArrayCreate(len).\r\n            var A = isCallable(C) ? Object(new C(len)) : new Array(len);\r\n\r\n            // 16. Let k be 0.\r\n            var k = 0;\r\n            // 17. Repeat, while k < len… (also steps a - h)\r\n            var kValue;\r\n            while (k < len) {\r\n                kValue = items[k];\r\n                if (mapFn) {\r\n                    A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);\r\n                } else {\r\n                    A[k] = kValue;\r\n                }\r\n                k += 1;\r\n            }\r\n            // 18. Let putStatus be Put(A, \"length\", len, true).\r\n            A.length = len;\r\n            // 20. Return A.\r\n            return A;\r\n        };\r\n    } ());\r\n}\r\n\r\n// jscs:enable\r\n/* jshint ignore:end */\r\n\n// jscs:disable\r\n/* jshint ignore:start */\r\n\r\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\nif (typeof Object.assign != 'function') {\r\n  Object.assign = function(target) {\r\n    'use strict';\r\n    if (target == null) {\r\n      throw new TypeError('Cannot convert undefined or null to object');\r\n    }\r\n\r\n    target = Object(target);\r\n    for (var index = 1; index < arguments.length; index++) {\r\n      var source = arguments[index];\r\n      if (source != null) {\r\n        for (var key in source) {\r\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n            target[key] = source[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return target;\r\n  };\r\n}\r\n\n// This is free and unencumbered software released into the public domain.\r\n// See LICENSE.md for more information.\r\n// jscs:disable\r\n/* jshint -W106 */\r\n/* jshint -W030 */\r\n/* jshint -W117 */\r\n/* jshint -W098 */\r\n/* jshint ignore:start */\r\n\r\n// If we're in node require encoding-indexes and attach it to the global.\r\n/**\r\n * @fileoverview Global |this| required for resolving indexes in node.\r\n * @suppress {globalThis}\r\n */\r\nif (typeof module !== \"undefined\" && module.exports) {\r\n  this[\"encoding-indexes\"] =\r\n    require(\"./encoding-indexes.js\")[\"encoding-indexes\"];\r\n}\r\n\r\n(function(global) {\r\n  'use strict';\r\n\r\n  //\r\n  // Utilities\r\n  //\r\n\r\n  /**\r\n   * @param {number} a The number to test.\r\n   * @param {number} min The minimum value in the range, inclusive.\r\n   * @param {number} max The maximum value in the range, inclusive.\r\n   * @return {boolean} True if a >= min and a <= max.\r\n   */\r\n  function inRange(a, min, max) {\r\n    return min <= a && a <= max;\r\n  }\r\n\r\n  /**\r\n   * @param {!Array.<*>} array The array to check.\r\n   * @param {*} item The item to look for in the array.\r\n   * @return {boolean} True if the item appears in the array.\r\n   */\r\n  function includes(array, item) {\r\n    return array.indexOf(item) !== -1;\r\n  }\r\n\r\n  var floor = Math.floor;\r\n\r\n  /**\r\n   * @param {*} o\r\n   * @return {Object}\r\n   */\r\n  function ToDictionary(o) {\r\n    if (o === undefined) return {};\r\n    if (o === Object(o)) return o;\r\n    throw TypeError('Could not convert argument to dictionary');\r\n  }\r\n\r\n  /**\r\n   * @param {string} string Input string of UTF-16 code units.\r\n   * @return {!Array.<number>} Code points.\r\n   */\r\n  function stringToCodePoints(string) {\r\n    // https://heycam.github.io/webidl/#dfn-obtain-unicode\r\n\r\n    // 1. Let S be the DOMString value.\r\n    var s = String(string);\r\n\r\n    // 2. Let n be the length of S.\r\n    var n = s.length;\r\n\r\n    // 3. Initialize i to 0.\r\n    var i = 0;\r\n\r\n    // 4. Initialize U to be an empty sequence of Unicode characters.\r\n    var u = [];\r\n\r\n    // 5. While i < n:\r\n    while (i < n) {\r\n\r\n      // 1. Let c be the code unit in S at index i.\r\n      var c = s.charCodeAt(i);\r\n\r\n      // 2. Depending on the value of c:\r\n\r\n      // c < 0xD800 or c > 0xDFFF\r\n      if (c < 0xD800 || c > 0xDFFF) {\r\n        // Append to U the Unicode character with code point c.\r\n        u.push(c);\r\n      }\r\n\r\n      // 0xDC00 ≤ c ≤ 0xDFFF\r\n      else if (0xDC00 <= c && c <= 0xDFFF) {\r\n        // Append to U a U+FFFD REPLACEMENT CHARACTER.\r\n        u.push(0xFFFD);\r\n      }\r\n\r\n      // 0xD800 ≤ c ≤ 0xDBFF\r\n      else if (0xD800 <= c && c <= 0xDBFF) {\r\n        // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\r\n        // CHARACTER.\r\n        if (i === n - 1) {\r\n          u.push(0xFFFD);\r\n        }\r\n        // 2. Otherwise, i < n−1:\r\n        else {\r\n          // 1. Let d be the code unit in S at index i+1.\r\n          var d = s.charCodeAt(i + 1);\r\n\r\n          // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\r\n          if (0xDC00 <= d && d <= 0xDFFF) {\r\n            // 1. Let a be c & 0x3FF.\r\n            var a = c & 0x3FF;\r\n\r\n            // 2. Let b be d & 0x3FF.\r\n            var b = d & 0x3FF;\r\n\r\n            // 3. Append to U the Unicode character with code point\r\n            // 2^16+2^10*a+b.\r\n            u.push(0x10000 + (a << 10) + b);\r\n\r\n            // 4. Set i to i+1.\r\n            i += 1;\r\n          }\r\n\r\n          // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\r\n          // U+FFFD REPLACEMENT CHARACTER.\r\n          else  {\r\n            u.push(0xFFFD);\r\n          }\r\n        }\r\n      }\r\n\r\n      // 3. Set i to i+1.\r\n      i += 1;\r\n    }\r\n\r\n    // 6. Return U.\r\n    return u;\r\n  }\r\n\r\n  /**\r\n   * @param {!Array.<number>} code_points Array of code points.\r\n   * @return {string} string String of UTF-16 code units.\r\n   */\r\n  function codePointsToString(code_points) {\r\n    var s = '';\r\n    for (var i = 0; i < code_points.length; ++i) {\r\n      var cp = code_points[i];\r\n      if (cp <= 0xFFFF) {\r\n        s += String.fromCharCode(cp);\r\n      } else {\r\n        cp -= 0x10000;\r\n        s += String.fromCharCode((cp >> 10) + 0xD800,\r\n                                 (cp & 0x3FF) + 0xDC00);\r\n      }\r\n    }\r\n    return s;\r\n  }\r\n\r\n\r\n  //\r\n  // Implementation of Encoding specification\r\n  // https://encoding.spec.whatwg.org/\r\n  //\r\n\r\n  //\r\n  // 4. Terminology\r\n  //\r\n\r\n  /**\r\n   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\r\n   * @param {number} a The number to test.\r\n   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\r\n   */\r\n  function isASCIIByte(a) {\r\n    return 0x00 <= a && a <= 0x7F;\r\n  }\r\n\r\n  /**\r\n   * An ASCII code point is a code point in the range U+0000 to\r\n   * U+007F, inclusive.\r\n   */\r\n  var isASCIICodePoint = isASCIIByte;\r\n\r\n\r\n  /**\r\n   * End-of-stream is a special token that signifies no more tokens\r\n   * are in the stream.\r\n   * @const\r\n   */ var end_of_stream = -1;\r\n\r\n  /**\r\n   * A stream represents an ordered sequence of tokens.\r\n   *\r\n   * @constructor\r\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\r\n   * the stream.\r\n   */\r\n  function Stream(tokens) {\r\n    /** @type {!Array.<number>} */\r\n    this.tokens = [].slice.call(tokens);\r\n    // Reversed as push/pop is more efficient than shift/unshift.\r\n    this.tokens.reverse();\r\n  }\r\n\r\n  Stream.prototype = {\r\n    /**\r\n     * @return {boolean} True if end-of-stream has been hit.\r\n     */\r\n    endOfStream: function() {\r\n      return !this.tokens.length;\r\n    },\r\n\r\n    /**\r\n     * When a token is read from a stream, the first token in the\r\n     * stream must be returned and subsequently removed, and\r\n     * end-of-stream must be returned otherwise.\r\n     *\r\n     * @return {number} Get the next token from the stream, or\r\n     * end_of_stream.\r\n     */\r\n     read: function() {\r\n      if (!this.tokens.length)\r\n        return end_of_stream;\r\n       return this.tokens.pop();\r\n     },\r\n\r\n    /**\r\n     * When one or more tokens are prepended to a stream, those tokens\r\n     * must be inserted, in given order, before the first token in the\r\n     * stream.\r\n     *\r\n     * @param {(number|!Array.<number>)} token The token(s) to prepend to the\r\n     * stream.\r\n     */\r\n    prepend: function(token) {\r\n      if (Array.isArray(token)) {\r\n        var tokens = /**@type {!Array.<number>}*/(token);\r\n        while (tokens.length)\r\n          this.tokens.push(tokens.pop());\r\n      } else {\r\n        this.tokens.push(token);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * When one or more tokens are pushed to a stream, those tokens\r\n     * must be inserted, in given order, after the last token in the\r\n     * stream.\r\n     *\r\n     * @param {(number|!Array.<number>)} token The tokens(s) to push to the\r\n     * stream.\r\n     */\r\n    push: function(token) {\r\n      if (Array.isArray(token)) {\r\n        var tokens = /**@type {!Array.<number>}*/(token);\r\n        while (tokens.length)\r\n          this.tokens.unshift(tokens.shift());\r\n      } else {\r\n        this.tokens.unshift(token);\r\n      }\r\n    }\r\n  };\r\n\r\n  //\r\n  // 5. Encodings\r\n  //\r\n\r\n  // 5.1 Encoders and decoders\r\n\r\n  /** @const */\r\n  var finished = -1;\r\n\r\n  /**\r\n   * @param {boolean} fatal If true, decoding errors raise an exception.\r\n   * @param {number=} opt_code_point Override the standard fallback code point.\r\n   * @return {number} The code point to insert on a decoding error.\r\n   */\r\n  function decoderError(fatal, opt_code_point) {\r\n    if (fatal)\r\n      throw TypeError('Decoder error');\r\n    return opt_code_point || 0xFFFD;\r\n  }\r\n\r\n  /**\r\n   * @param {number} code_point The code point that could not be encoded.\r\n   * @return {number} Always throws, no value is actually returned.\r\n   */\r\n  function encoderError(code_point) {\r\n    throw TypeError('The code point ' + code_point + ' could not be encoded.');\r\n  }\r\n\r\n  /** @interface */\r\n  function Decoder() {}\r\n  Decoder.prototype = {\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point, or |finished|.\r\n     */\r\n    handler: function(stream, bite) {}\r\n  };\r\n\r\n  /** @interface */\r\n  function Encoder() {}\r\n  Encoder.prototype = {\r\n    /**\r\n     * @param {Stream} stream The stream of code points being encoded.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\r\n     */\r\n    handler: function(stream, code_point) {}\r\n  };\r\n\r\n  // 5.2 Names and labels\r\n\r\n  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\r\n  // https://github.com/google/closure-compiler/issues/247\r\n\r\n  /**\r\n   * @param {string} label The encoding label.\r\n   * @return {?{name:string,labels:Array.<string>}}\r\n   */\r\n  function getEncoding(label) {\r\n    // 1. Remove any leading and trailing ASCII whitespace from label.\r\n    label = String(label).trim().toLowerCase();\r\n\r\n    // 2. If label is an ASCII case-insensitive match for any of the\r\n    // labels listed in the table below, return the corresponding\r\n    // encoding, and failure otherwise.\r\n    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\r\n      return label_to_encoding[label];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Encodings table: https://encoding.spec.whatwg.org/encodings.json\r\n   * @const\r\n   * @type {!Array.<{\r\n   *          heading: string,\r\n   *          encodings: Array.<{name:string,labels:Array.<string>}>\r\n   *        }>}\r\n   */\r\n  var encodings = [\r\n    {\r\n      \"encodings\": [\r\n        {\r\n          \"labels\": [\r\n            \"unicode-1-1-utf-8\",\r\n            \"utf-8\",\r\n            \"utf8\"\r\n          ],\r\n          \"name\": \"UTF-8\"\r\n        }\r\n      ],\r\n      \"heading\": \"The Encoding\"\r\n    },\r\n    {\r\n      \"encodings\": [\r\n        {\r\n          \"labels\": [\r\n            \"866\",\r\n            \"cp866\",\r\n            \"csibm866\",\r\n            \"ibm866\"\r\n          ],\r\n          \"name\": \"IBM866\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csisolatin2\",\r\n            \"iso-8859-2\",\r\n            \"iso-ir-101\",\r\n            \"iso8859-2\",\r\n            \"iso88592\",\r\n            \"iso_8859-2\",\r\n            \"iso_8859-2:1987\",\r\n            \"l2\",\r\n            \"latin2\"\r\n          ],\r\n          \"name\": \"ISO-8859-2\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csisolatin3\",\r\n            \"iso-8859-3\",\r\n            \"iso-ir-109\",\r\n            \"iso8859-3\",\r\n            \"iso88593\",\r\n            \"iso_8859-3\",\r\n            \"iso_8859-3:1988\",\r\n            \"l3\",\r\n            \"latin3\"\r\n          ],\r\n          \"name\": \"ISO-8859-3\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csisolatin4\",\r\n            \"iso-8859-4\",\r\n            \"iso-ir-110\",\r\n            \"iso8859-4\",\r\n            \"iso88594\",\r\n            \"iso_8859-4\",\r\n            \"iso_8859-4:1988\",\r\n            \"l4\",\r\n            \"latin4\"\r\n          ],\r\n          \"name\": \"ISO-8859-4\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csisolatincyrillic\",\r\n            \"cyrillic\",\r\n            \"iso-8859-5\",\r\n            \"iso-ir-144\",\r\n            \"iso8859-5\",\r\n            \"iso88595\",\r\n            \"iso_8859-5\",\r\n            \"iso_8859-5:1988\"\r\n          ],\r\n          \"name\": \"ISO-8859-5\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"arabic\",\r\n            \"asmo-708\",\r\n            \"csiso88596e\",\r\n            \"csiso88596i\",\r\n            \"csisolatinarabic\",\r\n            \"ecma-114\",\r\n            \"iso-8859-6\",\r\n            \"iso-8859-6-e\",\r\n            \"iso-8859-6-i\",\r\n            \"iso-ir-127\",\r\n            \"iso8859-6\",\r\n            \"iso88596\",\r\n            \"iso_8859-6\",\r\n            \"iso_8859-6:1987\"\r\n          ],\r\n          \"name\": \"ISO-8859-6\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csisolatingreek\",\r\n            \"ecma-118\",\r\n            \"elot_928\",\r\n            \"greek\",\r\n            \"greek8\",\r\n            \"iso-8859-7\",\r\n            \"iso-ir-126\",\r\n            \"iso8859-7\",\r\n            \"iso88597\",\r\n            \"iso_8859-7\",\r\n            \"iso_8859-7:1987\",\r\n            \"sun_eu_greek\"\r\n          ],\r\n          \"name\": \"ISO-8859-7\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csiso88598e\",\r\n            \"csisolatinhebrew\",\r\n            \"hebrew\",\r\n            \"iso-8859-8\",\r\n            \"iso-8859-8-e\",\r\n            \"iso-ir-138\",\r\n            \"iso8859-8\",\r\n            \"iso88598\",\r\n            \"iso_8859-8\",\r\n            \"iso_8859-8:1988\",\r\n            \"visual\"\r\n          ],\r\n          \"name\": \"ISO-8859-8\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csiso88598i\",\r\n            \"iso-8859-8-i\",\r\n            \"logical\"\r\n          ],\r\n          \"name\": \"ISO-8859-8-I\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csisolatin6\",\r\n            \"iso-8859-10\",\r\n            \"iso-ir-157\",\r\n            \"iso8859-10\",\r\n            \"iso885910\",\r\n            \"l6\",\r\n            \"latin6\"\r\n          ],\r\n          \"name\": \"ISO-8859-10\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"iso-8859-13\",\r\n            \"iso8859-13\",\r\n            \"iso885913\"\r\n          ],\r\n          \"name\": \"ISO-8859-13\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"iso-8859-14\",\r\n            \"iso8859-14\",\r\n            \"iso885914\"\r\n          ],\r\n          \"name\": \"ISO-8859-14\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csisolatin9\",\r\n            \"iso-8859-15\",\r\n            \"iso8859-15\",\r\n            \"iso885915\",\r\n            \"iso_8859-15\",\r\n            \"l9\"\r\n          ],\r\n          \"name\": \"ISO-8859-15\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"iso-8859-16\"\r\n          ],\r\n          \"name\": \"ISO-8859-16\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"cskoi8r\",\r\n            \"koi\",\r\n            \"koi8\",\r\n            \"koi8-r\",\r\n            \"koi8_r\"\r\n          ],\r\n          \"name\": \"KOI8-R\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"koi8-ru\",\r\n            \"koi8-u\"\r\n          ],\r\n          \"name\": \"KOI8-U\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csmacintosh\",\r\n            \"mac\",\r\n            \"macintosh\",\r\n            \"x-mac-roman\"\r\n          ],\r\n          \"name\": \"macintosh\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"dos-874\",\r\n            \"iso-8859-11\",\r\n            \"iso8859-11\",\r\n            \"iso885911\",\r\n            \"tis-620\",\r\n            \"windows-874\"\r\n          ],\r\n          \"name\": \"windows-874\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"cp1250\",\r\n            \"windows-1250\",\r\n            \"x-cp1250\"\r\n          ],\r\n          \"name\": \"windows-1250\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"cp1251\",\r\n            \"windows-1251\",\r\n            \"x-cp1251\"\r\n          ],\r\n          \"name\": \"windows-1251\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"ansi_x3.4-1968\",\r\n            \"ascii\",\r\n            \"cp1252\",\r\n            \"cp819\",\r\n            \"csisolatin1\",\r\n            \"ibm819\",\r\n            \"iso-8859-1\",\r\n            \"iso-ir-100\",\r\n            \"iso8859-1\",\r\n            \"iso88591\",\r\n            \"iso_8859-1\",\r\n            \"iso_8859-1:1987\",\r\n            \"l1\",\r\n            \"latin1\",\r\n            \"us-ascii\",\r\n            \"windows-1252\",\r\n            \"x-cp1252\"\r\n          ],\r\n          \"name\": \"windows-1252\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"cp1253\",\r\n            \"windows-1253\",\r\n            \"x-cp1253\"\r\n          ],\r\n          \"name\": \"windows-1253\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"cp1254\",\r\n            \"csisolatin5\",\r\n            \"iso-8859-9\",\r\n            \"iso-ir-148\",\r\n            \"iso8859-9\",\r\n            \"iso88599\",\r\n            \"iso_8859-9\",\r\n            \"iso_8859-9:1989\",\r\n            \"l5\",\r\n            \"latin5\",\r\n            \"windows-1254\",\r\n            \"x-cp1254\"\r\n          ],\r\n          \"name\": \"windows-1254\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"cp1255\",\r\n            \"windows-1255\",\r\n            \"x-cp1255\"\r\n          ],\r\n          \"name\": \"windows-1255\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"cp1256\",\r\n            \"windows-1256\",\r\n            \"x-cp1256\"\r\n          ],\r\n          \"name\": \"windows-1256\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"cp1257\",\r\n            \"windows-1257\",\r\n            \"x-cp1257\"\r\n          ],\r\n          \"name\": \"windows-1257\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"cp1258\",\r\n            \"windows-1258\",\r\n            \"x-cp1258\"\r\n          ],\r\n          \"name\": \"windows-1258\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"x-mac-cyrillic\",\r\n            \"x-mac-ukrainian\"\r\n          ],\r\n          \"name\": \"x-mac-cyrillic\"\r\n        }\r\n      ],\r\n      \"heading\": \"Legacy single-byte encodings\"\r\n    },\r\n    {\r\n      \"encodings\": [\r\n        {\r\n          \"labels\": [\r\n            \"chinese\",\r\n            \"csgb2312\",\r\n            \"csiso58gb231280\",\r\n            \"gb2312\",\r\n            \"gb_2312\",\r\n            \"gb_2312-80\",\r\n            \"gbk\",\r\n            \"iso-ir-58\",\r\n            \"x-gbk\"\r\n          ],\r\n          \"name\": \"GBK\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"gb18030\"\r\n          ],\r\n          \"name\": \"gb18030\"\r\n        }\r\n      ],\r\n      \"heading\": \"Legacy multi-byte Chinese (simplified) encodings\"\r\n    },\r\n    {\r\n      \"encodings\": [\r\n        {\r\n          \"labels\": [\r\n            \"big5\",\r\n            \"big5-hkscs\",\r\n            \"cn-big5\",\r\n            \"csbig5\",\r\n            \"x-x-big5\"\r\n          ],\r\n          \"name\": \"Big5\"\r\n        }\r\n      ],\r\n      \"heading\": \"Legacy multi-byte Chinese (traditional) encodings\"\r\n    },\r\n    {\r\n      \"encodings\": [\r\n        {\r\n          \"labels\": [\r\n            \"cseucpkdfmtjapanese\",\r\n            \"euc-jp\",\r\n            \"x-euc-jp\"\r\n          ],\r\n          \"name\": \"EUC-JP\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csiso2022jp\",\r\n            \"iso-2022-jp\"\r\n          ],\r\n          \"name\": \"ISO-2022-JP\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"csshiftjis\",\r\n            \"ms932\",\r\n            \"ms_kanji\",\r\n            \"shift-jis\",\r\n            \"shift_jis\",\r\n            \"sjis\",\r\n            \"windows-31j\",\r\n            \"x-sjis\"\r\n          ],\r\n          \"name\": \"Shift_JIS\"\r\n        }\r\n      ],\r\n      \"heading\": \"Legacy multi-byte Japanese encodings\"\r\n    },\r\n    {\r\n      \"encodings\": [\r\n        {\r\n          \"labels\": [\r\n            \"cseuckr\",\r\n            \"csksc56011987\",\r\n            \"euc-kr\",\r\n            \"iso-ir-149\",\r\n            \"korean\",\r\n            \"ks_c_5601-1987\",\r\n            \"ks_c_5601-1989\",\r\n            \"ksc5601\",\r\n            \"ksc_5601\",\r\n            \"windows-949\"\r\n          ],\r\n          \"name\": \"EUC-KR\"\r\n        }\r\n      ],\r\n      \"heading\": \"Legacy multi-byte Korean encodings\"\r\n    },\r\n    {\r\n      \"encodings\": [\r\n        {\r\n          \"labels\": [\r\n            \"csiso2022kr\",\r\n            \"hz-gb-2312\",\r\n            \"iso-2022-cn\",\r\n            \"iso-2022-cn-ext\",\r\n            \"iso-2022-kr\"\r\n          ],\r\n          \"name\": \"replacement\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"utf-16be\"\r\n          ],\r\n          \"name\": \"UTF-16BE\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"utf-16\",\r\n            \"utf-16le\"\r\n          ],\r\n          \"name\": \"UTF-16LE\"\r\n        },\r\n        {\r\n          \"labels\": [\r\n            \"x-user-defined\"\r\n          ],\r\n          \"name\": \"x-user-defined\"\r\n        }\r\n      ],\r\n      \"heading\": \"Legacy miscellaneous encodings\"\r\n    }\r\n  ];\r\n\r\n  // Label to encoding registry.\r\n  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */\r\n  var label_to_encoding = {};\r\n  encodings.forEach(function(category) {\r\n    category.encodings.forEach(function(encoding) {\r\n      encoding.labels.forEach(function(label) {\r\n        label_to_encoding[label] = encoding;\r\n      });\r\n    });\r\n  });\r\n\r\n  // Registry of of encoder/decoder factories, by encoding name.\r\n  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */\r\n  var encoders = {};\r\n  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */\r\n  var decoders = {};\r\n\r\n  //\r\n  // 6. Indexes\r\n  //\r\n\r\n  /**\r\n   * @param {number} pointer The |pointer| to search for.\r\n   * @param {(!Array.<?number>|undefined)} index The |index| to search within.\r\n   * @return {?number} The code point corresponding to |pointer| in |index|,\r\n   *     or null if |code point| is not in |index|.\r\n   */\r\n  function indexCodePointFor(pointer, index) {\r\n    if (!index) return null;\r\n    return index[pointer] || null;\r\n  }\r\n\r\n  /**\r\n   * @param {number} code_point The |code point| to search for.\r\n   * @param {!Array.<?number>} index The |index| to search within.\r\n   * @return {?number} The first pointer corresponding to |code point| in\r\n   *     |index|, or null if |code point| is not in |index|.\r\n   */\r\n  function indexPointerFor(code_point, index) {\r\n    var pointer = index.indexOf(code_point);\r\n    return pointer === -1 ? null : pointer;\r\n  }\r\n\r\n  /**\r\n   * @param {string} name Name of the index.\r\n   * @return {(!Array.<number>|!Array.<Array.<number>>)}\r\n   *  */\r\n  function index(name) {\r\n    if (!('encoding-indexes' in global)) {\r\n      throw Error(\"Indexes missing.\" +\r\n                  \" Did you forget to include encoding-indexes.js?\");\r\n    }\r\n    return global['encoding-indexes'][name];\r\n  }\r\n\r\n  /**\r\n   * @param {number} pointer The |pointer| to search for in the gb18030 index.\r\n   * @return {?number} The code point corresponding to |pointer| in |index|,\r\n   *     or null if |code point| is not in the gb18030 index.\r\n   */\r\n  function indexGB18030RangesCodePointFor(pointer) {\r\n    // 1. If pointer is greater than 39419 and less than 189000, or\r\n    // pointer is greater than 1237575, return null.\r\n    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))\r\n      return null;\r\n\r\n    // 2. If pointer is 7457, return code point U+E7C7.\r\n    if (pointer === 7457) return 0xE7C7;\r\n\r\n    // 3. Let offset be the last pointer in index gb18030 ranges that\r\n    // is equal to or less than pointer and let code point offset be\r\n    // its corresponding code point.\r\n    var offset = 0;\r\n    var code_point_offset = 0;\r\n    var idx = index('gb18030');\r\n    var i;\r\n    for (i = 0; i < idx.length; ++i) {\r\n      /** @type {!Array.<number>} */\r\n      var entry = idx[i];\r\n      if (entry[0] <= pointer) {\r\n        offset = entry[0];\r\n        code_point_offset = entry[1];\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // 4. Return a code point whose value is code point offset +\r\n    // pointer − offset.\r\n    return code_point_offset + pointer - offset;\r\n  }\r\n\r\n  /**\r\n   * @param {number} code_point The |code point| to locate in the gb18030 index.\r\n   * @return {number} The first pointer corresponding to |code point| in the\r\n   *     gb18030 index.\r\n   */\r\n  function indexGB18030RangesPointerFor(code_point) {\r\n    // 1. If code point is U+E7C7, return pointer 7457.\r\n    if (code_point === 0xE7C7) return 7457;\r\n\r\n    // 2. Let offset be the last code point in index gb18030 ranges\r\n    // that is equal to or less than code point and let pointer offset\r\n    // be its corresponding pointer.\r\n    var offset = 0;\r\n    var pointer_offset = 0;\r\n    var idx = index('gb18030');\r\n    var i;\r\n    for (i = 0; i < idx.length; ++i) {\r\n      /** @type {!Array.<number>} */\r\n      var entry = idx[i];\r\n      if (entry[1] <= code_point) {\r\n        offset = entry[1];\r\n        pointer_offset = entry[0];\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // 3. Return a pointer whose value is pointer offset + code point\r\n    // − offset.\r\n    return pointer_offset + code_point - offset;\r\n  }\r\n\r\n  /**\r\n   * @param {number} code_point The |code_point| to search for in the shift_jis\r\n   *     index.\r\n   * @return {?number} The code point corresponding to |pointer| in |index|,\r\n   *     or null if |code point| is not in the shift_jis index.\r\n   */\r\n  function indexShiftJISPointerFor(code_point) {\r\n    // 1. Let index be index jis0208 excluding all pointers in the\r\n    // range 8272 to 8835.\r\n    var pointer = indexPointerFor(code_point, index('jis0208'));\r\n    if (pointer === null || inRange(pointer, 8272, 8835))\r\n      return null;\r\n\r\n    // 2. Return the index pointer for code point in index.\r\n    return pointer;\r\n  }\r\n\r\n  /**\r\n   * @param {number} code_point The |code_point| to search for in the big5\r\n   *     index.\r\n   * @return {?number} The code point corresponding to |pointer| in |index|,\r\n   *     or null if |code point| is not in the big5 index.\r\n   */\r\n  function indexBig5PointerFor(code_point) {\r\n\r\n    // 1. Let index be index big5.\r\n    var index_ = index('big5');\r\n\r\n    // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\r\n    // U+5345, return the last pointer corresponding to code point in\r\n    // index.\r\n    if (code_point === 0x2550 || code_point === 0x255E ||\r\n        code_point === 0x2561 || code_point === 0x256A ||\r\n        code_point === 0x5341 || code_point === 0x5345) {\r\n      return index_.lastIndexOf(code_point);\r\n    }\r\n\r\n    // 3. Return the index pointer for code point in index.\r\n    return indexPointerFor(code_point, index_);\r\n  }\r\n\r\n  //\r\n  // 8. API\r\n  //\r\n\r\n  /** @const */ var DEFAULT_ENCODING = 'utf-8';\r\n\r\n  // 8.1 Interface TextDecoder\r\n\r\n  /**\r\n   * @constructor\r\n   * @param {string=} label The label of the encoding;\r\n   *     defaults to 'utf-8'.\r\n   * @param {Object=} options\r\n   */\r\n  function TextDecoder(label, options) {\r\n    // Web IDL conventions\r\n    if (!(this instanceof TextDecoder))\r\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\r\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\r\n    options = ToDictionary(options);\r\n\r\n    // A TextDecoder object has an associated encoding, decoder,\r\n    // stream, ignore BOM flag (initially unset), BOM seen flag\r\n    // (initially unset), error mode (initially replacement), and do\r\n    // not flush flag (initially unset).\r\n\r\n    /** @private */\r\n    this._encoding = null;\r\n    /** @private @type {?Decoder} */\r\n    this._decoder = null;\r\n    /** @private @type {boolean} */\r\n    this._ignoreBOM = false;\r\n    /** @private @type {boolean} */\r\n    this._BOMseen = false;\r\n    /** @private @type {string} */\r\n    this._error_mode = 'replacement';\r\n    /** @private @type {boolean} */\r\n    this._do_not_flush = false;\r\n\r\n\r\n    // 1. Let encoding be the result of getting an encoding from\r\n    // label.\r\n    var encoding = getEncoding(label);\r\n\r\n    // 2. If encoding is failure or replacement, throw a RangeError.\r\n    if (encoding === null || encoding.name === 'replacement')\r\n      throw RangeError('Unknown encoding: ' + label);\r\n    if (!decoders[encoding.name]) {\r\n      throw Error('Decoder not present.' +\r\n                  ' Did you forget to include encoding-indexes.js?');\r\n    }\r\n\r\n    // 3. Let dec be a new TextDecoder object.\r\n    var dec = this;\r\n\r\n    // 4. Set dec's encoding to encoding.\r\n    dec._encoding = encoding;\r\n\r\n    // 5. If options's fatal member is true, set dec's error mode to\r\n    // fatal.\r\n    if (Boolean(options['fatal']))\r\n      dec._error_mode = 'fatal';\r\n\r\n    // 6. If options's ignoreBOM member is true, set dec's ignore BOM\r\n    // flag.\r\n    if (Boolean(options['ignoreBOM']))\r\n      dec._ignoreBOM = true;\r\n\r\n    // For pre-ES5 runtimes:\r\n    if (!Object.defineProperty) {\r\n      this.encoding = dec._encoding.name.toLowerCase();\r\n      this.fatal = dec._error_mode === 'fatal';\r\n      this.ignoreBOM = dec._ignoreBOM;\r\n    }\r\n\r\n    // 7. Return dec.\r\n    return dec;\r\n  }\r\n\r\n  if (Object.defineProperty) {\r\n    // The encoding attribute's getter must return encoding's name.\r\n    Object.defineProperty(TextDecoder.prototype, 'encoding', {\r\n      /** @this {TextDecoder} */\r\n      get: function() { return this._encoding.name.toLowerCase(); }\r\n    });\r\n\r\n    // The fatal attribute's getter must return true if error mode\r\n    // is fatal, and false otherwise.\r\n    Object.defineProperty(TextDecoder.prototype, 'fatal', {\r\n      /** @this {TextDecoder} */\r\n      get: function() { return this._error_mode === 'fatal'; }\r\n    });\r\n\r\n    // The ignoreBOM attribute's getter must return true if ignore\r\n    // BOM flag is set, and false otherwise.\r\n    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\r\n      /** @this {TextDecoder} */\r\n      get: function() { return this._ignoreBOM; }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {BufferSource=} input The buffer of bytes to decode.\r\n   * @param {Object=} options\r\n   * @return {string} The decoded string.\r\n   */\r\n  TextDecoder.prototype.decode = function decode(input, options) {\r\n    var bytes;\r\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\r\n      bytes = new Uint8Array(input);\r\n    } else if (typeof input === 'object' && 'buffer' in input &&\r\n               input.buffer instanceof ArrayBuffer) {\r\n      bytes = new Uint8Array(input.buffer,\r\n                             input.byteOffset,\r\n                             input.byteLength);\r\n    } else {\r\n      bytes = new Uint8Array(0);\r\n    }\r\n\r\n    options = ToDictionary(options);\r\n\r\n    // 1. If the do not flush flag is unset, set decoder to a new\r\n    // encoding's decoder, set stream to a new stream, and unset the\r\n    // BOM seen flag.\r\n    if (!this._do_not_flush) {\r\n      this._decoder = decoders[this._encoding.name]({\r\n        fatal: this._error_mode === 'fatal'});\r\n      this._BOMseen = false;\r\n    }\r\n\r\n    // 2. If options's stream is true, set the do not flush flag, and\r\n    // unset the do not flush flag otherwise.\r\n    this._do_not_flush = Boolean(options['stream']);\r\n\r\n    // 3. If input is given, push a copy of input to stream.\r\n    // TODO: Align with spec algorithm - maintain stream on instance.\r\n    var input_stream = new Stream(bytes);\r\n\r\n    // 4. Let output be a new stream.\r\n    var output = [];\r\n\r\n    /** @type {?(number|!Array.<number>)} */\r\n    var result;\r\n\r\n    // 5. While true:\r\n    while (true) {\r\n      // 1. Let token be the result of reading from stream.\r\n      var token = input_stream.read();\r\n\r\n      // 2. If token is end-of-stream and the do not flush flag is\r\n      // set, return output, serialized.\r\n      // TODO: Align with spec algorithm.\r\n      if (token === end_of_stream)\r\n        break;\r\n\r\n      // 3. Otherwise, run these subsubsteps:\r\n\r\n      // 1. Let result be the result of processing token for decoder,\r\n      // stream, output, and error mode.\r\n      result = this._decoder.handler(input_stream, token);\r\n\r\n      // 2. If result is finished, return output, serialized.\r\n      if (result === finished)\r\n        break;\r\n\r\n      if (result !== null) {\r\n        if (Array.isArray(result))\r\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\r\n        else\r\n          output.push(result);\r\n      }\r\n\r\n      // 3. Otherwise, if result is error, throw a TypeError.\r\n      // (Thrown in handler)\r\n\r\n      // 4. Otherwise, do nothing.\r\n    }\r\n    // TODO: Align with spec algorithm.\r\n    if (!this._do_not_flush) {\r\n      do {\r\n        result = this._decoder.handler(input_stream, input_stream.read());\r\n        if (result === finished)\r\n          break;\r\n        if (result === null)\r\n          continue;\r\n        if (Array.isArray(result))\r\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\r\n        else\r\n          output.push(result);\r\n      } while (!input_stream.endOfStream());\r\n      this._decoder = null;\r\n    }\r\n\r\n    // A TextDecoder object also has an associated serialize stream\r\n    // algorithm...\r\n    /**\r\n     * @param {!Array.<number>} stream\r\n     * @return {string}\r\n     * @this {TextDecoder}\r\n     */\r\n    function serializeStream(stream) {\r\n      // 1. Let token be the result of reading from stream.\r\n      // (Done in-place on array, rather than as a stream)\r\n\r\n      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\r\n      // BOM flag and BOM seen flag are unset, run these subsubsteps:\r\n      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&\r\n          !this._ignoreBOM && !this._BOMseen) {\r\n        if (stream.length > 0 && stream[0] === 0xFEFF) {\r\n          // 1. If token is U+FEFF, set BOM seen flag.\r\n          this._BOMseen = true;\r\n          stream.shift();\r\n        } else if (stream.length > 0) {\r\n          // 2. Otherwise, if token is not end-of-stream, set BOM seen\r\n          // flag and append token to stream.\r\n          this._BOMseen = true;\r\n        } else {\r\n          // 3. Otherwise, if token is not end-of-stream, append token\r\n          // to output.\r\n          // (no-op)\r\n        }\r\n      }\r\n      // 4. Otherwise, return output.\r\n      return codePointsToString(stream);\r\n    }\r\n\r\n    return serializeStream.call(this, output);\r\n  };\r\n\r\n  // 8.2 Interface TextEncoder\r\n\r\n  /**\r\n   * @constructor\r\n   * @param {string=} label The label of the encoding. NONSTANDARD.\r\n   * @param {Object=} options NONSTANDARD.\r\n   */\r\n  function TextEncoder(label, options) {\r\n    // Web IDL conventions\r\n    if (!(this instanceof TextEncoder))\r\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\r\n    options = ToDictionary(options);\r\n\r\n    // A TextEncoder object has an associated encoding and encoder.\r\n\r\n    /** @private */\r\n    this._encoding = null;\r\n    /** @private @type {?Encoder} */\r\n    this._encoder = null;\r\n\r\n    // Non-standard\r\n    /** @private @type {boolean} */\r\n    this._do_not_flush = false;\r\n    /** @private @type {string} */\r\n    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\r\n\r\n    // 1. Let enc be a new TextEncoder object.\r\n    var enc = this;\r\n\r\n    // 2. Set enc's encoding to UTF-8's encoder.\r\n    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\r\n      // NONSTANDARD behavior.\r\n      label = label !== undefined ? String(label) : DEFAULT_ENCODING;\r\n      var encoding = getEncoding(label);\r\n      if (encoding === null || encoding.name === 'replacement')\r\n        throw RangeError('Unknown encoding: ' + label);\r\n      if (!encoders[encoding.name]) {\r\n        throw Error('Encoder not present.' +\r\n                    ' Did you forget to include encoding-indexes.js?');\r\n      }\r\n      enc._encoding = encoding;\r\n    } else {\r\n      // Standard behavior.\r\n      enc._encoding = getEncoding('utf-8');\r\n\r\n      if (label !== undefined && 'console' in global) {\r\n        console.warn('TextEncoder constructor called with encoding label, '\r\n                     + 'which is ignored.');\r\n      }\r\n    }\r\n\r\n    // For pre-ES5 runtimes:\r\n    if (!Object.defineProperty)\r\n      this.encoding = enc._encoding.name.toLowerCase();\r\n\r\n    // 3. Return enc.\r\n    return enc;\r\n  }\r\n\r\n  if (Object.defineProperty) {\r\n    // The encoding attribute's getter must return encoding's name.\r\n    Object.defineProperty(TextEncoder.prototype, 'encoding', {\r\n      /** @this {TextEncoder} */\r\n      get: function() { return this._encoding.name.toLowerCase(); }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {string=} opt_string The string to encode.\r\n   * @param {Object=} options\r\n   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\r\n   */\r\n  TextEncoder.prototype.encode = function encode(opt_string, options) {\r\n    opt_string = opt_string ? String(opt_string) : '';\r\n    options = ToDictionary(options);\r\n\r\n    // NOTE: This option is nonstandard. None of the encodings\r\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\r\n    // the input is a USVString so streaming is not necessary.\r\n    if (!this._do_not_flush)\r\n      this._encoder = encoders[this._encoding.name]({\r\n        fatal: this._fatal === 'fatal'});\r\n    this._do_not_flush = Boolean(options['stream']);\r\n\r\n    // 1. Convert input to a stream.\r\n    var input = new Stream(stringToCodePoints(opt_string));\r\n\r\n    // 2. Let output be a new stream\r\n    var output = [];\r\n\r\n    /** @type {?(number|!Array.<number>)} */\r\n    var result;\r\n    // 3. While true, run these substeps:\r\n    while (true) {\r\n      // 1. Let token be the result of reading from input.\r\n      var token = input.read();\r\n      if (token === end_of_stream)\r\n        break;\r\n      // 2. Let result be the result of processing token for encoder,\r\n      // input, output.\r\n      result = this._encoder.handler(input, token);\r\n      if (result === finished)\r\n        break;\r\n      if (Array.isArray(result))\r\n        output.push.apply(output, /**@type {!Array.<number>}*/(result));\r\n      else\r\n        output.push(result);\r\n    }\r\n    // TODO: Align with spec algorithm.\r\n    if (!this._do_not_flush) {\r\n      while (true) {\r\n        result = this._encoder.handler(input, input.read());\r\n        if (result === finished)\r\n          break;\r\n        if (Array.isArray(result))\r\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\r\n        else\r\n          output.push(result);\r\n      }\r\n      this._encoder = null;\r\n    }\r\n    // 3. If result is finished, convert output into a byte sequence,\r\n    // and then return a Uint8Array object wrapping an ArrayBuffer\r\n    // containing output.\r\n    return new Uint8Array(output);\r\n  };\r\n\r\n\r\n  //\r\n  // 9. The encoding\r\n  //\r\n\r\n  // 9.1 utf-8\r\n\r\n  // 9.1.1 utf-8 decoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Decoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function UTF8Decoder(options) {\r\n    var fatal = options.fatal;\r\n\r\n    // utf-8's decoder's has an associated utf-8 code point, utf-8\r\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\r\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\r\n    // (initially 0xBF).\r\n    var /** @type {number} */ utf8_code_point = 0,\r\n        /** @type {number} */ utf8_bytes_seen = 0,\r\n        /** @type {number} */ utf8_bytes_needed = 0,\r\n        /** @type {number} */ utf8_lower_boundary = 0x80,\r\n        /** @type {number} */ utf8_upper_boundary = 0xBF;\r\n\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point.\r\n     */\r\n    this.handler = function(stream, bite) {\r\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\r\n      // set utf-8 bytes needed to 0 and return error.\r\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\r\n        utf8_bytes_needed = 0;\r\n        return decoderError(fatal);\r\n      }\r\n\r\n      // 2. If byte is end-of-stream, return finished.\r\n      if (bite === end_of_stream)\r\n        return finished;\r\n\r\n      // 3. If utf-8 bytes needed is 0, based on byte:\r\n      if (utf8_bytes_needed === 0) {\r\n\r\n        // 0x00 to 0x7F\r\n        if (inRange(bite, 0x00, 0x7F)) {\r\n          // Return a code point whose value is byte.\r\n          return bite;\r\n        }\r\n\r\n        // 0xC2 to 0xDF\r\n        else if (inRange(bite, 0xC2, 0xDF)) {\r\n          // 1. Set utf-8 bytes needed to 1.\r\n          utf8_bytes_needed = 1;\r\n\r\n          // 2. Set UTF-8 code point to byte & 0x1F.\r\n          utf8_code_point = bite & 0x1F;\r\n        }\r\n\r\n        // 0xE0 to 0xEF\r\n        else if (inRange(bite, 0xE0, 0xEF)) {\r\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\r\n          if (bite === 0xE0)\r\n            utf8_lower_boundary = 0xA0;\r\n          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\r\n          if (bite === 0xED)\r\n            utf8_upper_boundary = 0x9F;\r\n          // 3. Set utf-8 bytes needed to 2.\r\n          utf8_bytes_needed = 2;\r\n          // 4. Set UTF-8 code point to byte & 0xF.\r\n          utf8_code_point = bite & 0xF;\r\n        }\r\n\r\n        // 0xF0 to 0xF4\r\n        else if (inRange(bite, 0xF0, 0xF4)) {\r\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\r\n          if (bite === 0xF0)\r\n            utf8_lower_boundary = 0x90;\r\n          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\r\n          if (bite === 0xF4)\r\n            utf8_upper_boundary = 0x8F;\r\n          // 3. Set utf-8 bytes needed to 3.\r\n          utf8_bytes_needed = 3;\r\n          // 4. Set UTF-8 code point to byte & 0x7.\r\n          utf8_code_point = bite & 0x7;\r\n        }\r\n\r\n        // Otherwise\r\n        else {\r\n          // Return error.\r\n          return decoderError(fatal);\r\n        }\r\n\r\n        // Return continue.\r\n        return null;\r\n      }\r\n\r\n      // 4. If byte is not in the range utf-8 lower boundary to utf-8\r\n      // upper boundary, inclusive, run these substeps:\r\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\r\n\r\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\r\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\r\n        // utf-8 upper boundary to 0xBF.\r\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\r\n        utf8_lower_boundary = 0x80;\r\n        utf8_upper_boundary = 0xBF;\r\n\r\n        // 2. Prepend byte to stream.\r\n        stream.prepend(bite);\r\n\r\n        // 3. Return error.\r\n        return decoderError(fatal);\r\n      }\r\n\r\n      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\r\n      // to 0xBF.\r\n      utf8_lower_boundary = 0x80;\r\n      utf8_upper_boundary = 0xBF;\r\n\r\n      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\r\n      // 0x3F)\r\n      utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F);\r\n\r\n      // 7. Increase utf-8 bytes seen by one.\r\n      utf8_bytes_seen += 1;\r\n\r\n      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\r\n      // continue.\r\n      if (utf8_bytes_seen !== utf8_bytes_needed)\r\n        return null;\r\n\r\n      // 9. Let code point be utf-8 code point.\r\n      var code_point = utf8_code_point;\r\n\r\n      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\r\n      // seen to 0.\r\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\r\n\r\n      // 11. Return a code point whose value is code point.\r\n      return code_point;\r\n    };\r\n  }\r\n\r\n  // 9.1.2 utf-8 encoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Encoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function UTF8Encoder(options) {\r\n    var fatal = options.fatal;\r\n    /**\r\n     * @param {Stream} stream Input stream.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\r\n     */\r\n    this.handler = function(stream, code_point) {\r\n      // 1. If code point is end-of-stream, return finished.\r\n      if (code_point === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If code point is in the range U+0000 to U+007F, return a\r\n      // byte whose value is code point.\r\n      if (inRange(code_point, 0x0000, 0x007f))\r\n        return code_point;\r\n\r\n      // 3. Set count and offset based on the range code point is in:\r\n      var count, offset;\r\n      // U+0080 to U+07FF, inclusive:\r\n      if (inRange(code_point, 0x0080, 0x07FF)) {\r\n        // 1 and 0xC0\r\n        count = 1;\r\n        offset = 0xC0;\r\n      }\r\n      // U+0800 to U+FFFF, inclusive:\r\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\r\n        // 2 and 0xE0\r\n        count = 2;\r\n        offset = 0xE0;\r\n      }\r\n      // U+10000 to U+10FFFF, inclusive:\r\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\r\n        // 3 and 0xF0\r\n        count = 3;\r\n        offset = 0xF0;\r\n      }\r\n\r\n      // 4.Let bytes be a byte sequence whose first byte is (code\r\n      // point >> (6 × count)) + offset.\r\n      var bytes = [(code_point >> (6 * count)) + offset];\r\n\r\n      // 5. Run these substeps while count is greater than 0:\r\n      while (count > 0) {\r\n\r\n        // 1. Set temp to code point >> (6 × (count − 1)).\r\n        var temp = code_point >> (6 * (count - 1));\r\n\r\n        // 2. Append to bytes 0x80 | (temp & 0x3F).\r\n        bytes.push(0x80 | (temp & 0x3F));\r\n\r\n        // 3. Decrease count by one.\r\n        count -= 1;\r\n      }\r\n\r\n      // 6. Return bytes bytes, in order.\r\n      return bytes;\r\n    };\r\n  }\r\n\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['UTF-8'] = function(options) {\r\n    return new UTF8Encoder(options);\r\n  };\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['UTF-8'] = function(options) {\r\n    return new UTF8Decoder(options);\r\n  };\r\n\r\n  //\r\n  // 10. Legacy single-byte encodings\r\n  //\r\n\r\n  // 10.1 single-byte decoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Decoder}\r\n   * @param {!Array.<number>} index The encoding index.\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function SingleByteDecoder(index, options) {\r\n    var fatal = options.fatal;\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point.\r\n     */\r\n    this.handler = function(stream, bite) {\r\n      // 1. If byte is end-of-stream, return finished.\r\n      if (bite === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If byte is an ASCII byte, return a code point whose value\r\n      // is byte.\r\n      if (isASCIIByte(bite))\r\n        return bite;\r\n\r\n      // 3. Let code point be the index code point for byte − 0x80 in\r\n      // index single-byte.\r\n      var code_point = index[bite - 0x80];\r\n\r\n      // 4. If code point is null, return error.\r\n      if (code_point === null)\r\n        return decoderError(fatal);\r\n\r\n      // 5. Return a code point whose value is code point.\r\n      return code_point;\r\n    };\r\n  }\r\n\r\n  // 10.2 single-byte encoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Encoder}\r\n   * @param {!Array.<?number>} index The encoding index.\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function SingleByteEncoder(index, options) {\r\n    var fatal = options.fatal;\r\n    /**\r\n     * @param {Stream} stream Input stream.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\r\n     */\r\n    this.handler = function(stream, code_point) {\r\n      // 1. If code point is end-of-stream, return finished.\r\n      if (code_point === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If code point is an ASCII code point, return a byte whose\r\n      // value is code point.\r\n      if (isASCIICodePoint(code_point))\r\n        return code_point;\r\n\r\n      // 3. Let pointer be the index pointer for code point in index\r\n      // single-byte.\r\n      var pointer = indexPointerFor(code_point, index);\r\n\r\n      // 4. If pointer is null, return error with code point.\r\n      if (pointer === null)\r\n        encoderError(code_point);\r\n\r\n      // 5. Return a byte whose value is pointer + 0x80.\r\n      return pointer + 0x80;\r\n    };\r\n  }\r\n\r\n  (function() {\r\n    if (!('encoding-indexes' in global))\r\n      return;\r\n    encodings.forEach(function(category) {\r\n      if (category.heading !== 'Legacy single-byte encodings')\r\n        return;\r\n      category.encodings.forEach(function(encoding) {\r\n        var name = encoding.name;\r\n        var idx = index(name.toLowerCase());\r\n        /** @param {{fatal: boolean}} options */\r\n        decoders[name] = function(options) {\r\n          return new SingleByteDecoder(idx, options);\r\n        };\r\n        /** @param {{fatal: boolean}} options */\r\n        encoders[name] = function(options) {\r\n          return new SingleByteEncoder(idx, options);\r\n        };\r\n      });\r\n    });\r\n  }());\r\n\r\n  //\r\n  // 11. Legacy multi-byte Chinese (simplified) encodings\r\n  //\r\n\r\n  // 11.1 gbk\r\n\r\n  // 11.1.1 gbk decoder\r\n  // gbk's decoder is gb18030's decoder.\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['GBK'] = function(options) {\r\n    return new GB18030Decoder(options);\r\n  };\r\n\r\n  // 11.1.2 gbk encoder\r\n  // gbk's encoder is gb18030's encoder with its gbk flag set.\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['GBK'] = function(options) {\r\n    return new GB18030Encoder(options, true);\r\n  };\r\n\r\n  // 11.2 gb18030\r\n\r\n  // 11.2.1 gb18030 decoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Decoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function GB18030Decoder(options) {\r\n    var fatal = options.fatal;\r\n    // gb18030's decoder has an associated gb18030 first, gb18030\r\n    // second, and gb18030 third (all initially 0x00).\r\n    var /** @type {number} */ gb18030_first = 0x00,\r\n        /** @type {number} */ gb18030_second = 0x00,\r\n        /** @type {number} */ gb18030_third = 0x00;\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point.\r\n     */\r\n    this.handler = function(stream, bite) {\r\n      // 1. If byte is end-of-stream and gb18030 first, gb18030\r\n      // second, and gb18030 third are 0x00, return finished.\r\n      if (bite === end_of_stream && gb18030_first === 0x00 &&\r\n          gb18030_second === 0x00 && gb18030_third === 0x00) {\r\n        return finished;\r\n      }\r\n      // 2. If byte is end-of-stream, and gb18030 first, gb18030\r\n      // second, or gb18030 third is not 0x00, set gb18030 first,\r\n      // gb18030 second, and gb18030 third to 0x00, and return error.\r\n      if (bite === end_of_stream &&\r\n          (gb18030_first !== 0x00 || gb18030_second !== 0x00 ||\r\n           gb18030_third !== 0x00)) {\r\n        gb18030_first = 0x00;\r\n        gb18030_second = 0x00;\r\n        gb18030_third = 0x00;\r\n        decoderError(fatal);\r\n      }\r\n      var code_point;\r\n      // 3. If gb18030 third is not 0x00, run these substeps:\r\n      if (gb18030_third !== 0x00) {\r\n        // 1. Let code point be null.\r\n        code_point = null;\r\n        // 2. If byte is in the range 0x30 to 0x39, set code point to\r\n        // the index gb18030 ranges code point for (((gb18030 first −\r\n        // 0x81) × 10 + gb18030 second − 0x30) × 126 + gb18030 third −\r\n        // 0x81) × 10 + byte − 0x30.\r\n        if (inRange(bite, 0x30, 0x39)) {\r\n          code_point = indexGB18030RangesCodePointFor(\r\n              (((gb18030_first - 0x81) * 10 + (gb18030_second - 0x30)) * 126 +\r\n               (gb18030_third - 0x81)) * 10 + bite - 0x30);\r\n        }\r\n\r\n        // 3. Let buffer be a byte sequence consisting of gb18030\r\n        // second, gb18030 third, and byte, in order.\r\n        var buffer = [gb18030_second, gb18030_third, bite];\r\n\r\n        // 4. Set gb18030 first, gb18030 second, and gb18030 third to\r\n        // 0x00.\r\n        gb18030_first = 0x00;\r\n        gb18030_second = 0x00;\r\n        gb18030_third = 0x00;\r\n\r\n        // 5. If code point is null, prepend buffer to stream and\r\n        // return error.\r\n        if (code_point === null) {\r\n          stream.prepend(buffer);\r\n          return decoderError(fatal);\r\n        }\r\n\r\n        // 6. Return a code point whose value is code point.\r\n        return code_point;\r\n      }\r\n\r\n      // 4. If gb18030 second is not 0x00, run these substeps:\r\n      if (gb18030_second !== 0x00) {\r\n\r\n        // 1. If byte is in the range 0x81 to 0xFE, set gb18030 third\r\n        // to byte and return continue.\r\n        if (inRange(bite, 0x81, 0xFE)) {\r\n          gb18030_third = bite;\r\n          return null;\r\n        }\r\n\r\n        // 2. Prepend gb18030 second followed by byte to stream, set\r\n        // gb18030 first and gb18030 second to 0x00, and return error.\r\n        stream.prepend([gb18030_second, bite]);\r\n        gb18030_first = 0x00;\r\n        gb18030_second = 0x00;\r\n        return decoderError(fatal);\r\n      }\r\n\r\n      // 5. If gb18030 first is not 0x00, run these substeps:\r\n      if (gb18030_first !== 0x00) {\r\n\r\n        // 1. If byte is in the range 0x30 to 0x39, set gb18030 second\r\n        // to byte and return continue.\r\n        if (inRange(bite, 0x30, 0x39)) {\r\n          gb18030_second = bite;\r\n          return null;\r\n        }\r\n\r\n        // 2. Let lead be gb18030 first, let pointer be null, and set\r\n        // gb18030 first to 0x00.\r\n        var lead = gb18030_first;\r\n        var pointer = null;\r\n        gb18030_first = 0x00;\r\n\r\n        // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\r\n        // otherwise.\r\n        var offset = bite < 0x7F ? 0x40 : 0x41;\r\n\r\n        // 4. If byte is in the range 0x40 to 0x7E or 0x80 to 0xFE,\r\n        // set pointer to (lead − 0x81) × 190 + (byte − offset).\r\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))\r\n          pointer = (lead - 0x81) * 190 + (bite - offset);\r\n\r\n        // 5. Let code point be null if pointer is null and the index\r\n        // code point for pointer in index gb18030 otherwise.\r\n        code_point = pointer === null ? null :\r\n            indexCodePointFor(pointer, index('gb18030'));\r\n\r\n        // 6. If code point is null and byte is an ASCII byte, prepend\r\n        // byte to stream.\r\n        if (code_point === null && isASCIIByte(bite))\r\n          stream.prepend(bite);\r\n\r\n        // 7. If code point is null, return error.\r\n        if (code_point === null)\r\n          return decoderError(fatal);\r\n\r\n        // 8. Return a code point whose value is code point.\r\n        return code_point;\r\n      }\r\n\r\n      // 6. If byte is an ASCII byte, return a code point whose value\r\n      // is byte.\r\n      if (isASCIIByte(bite))\r\n        return bite;\r\n\r\n      // 7. If byte is 0x80, return code point U+20AC.\r\n      if (bite === 0x80)\r\n        return 0x20AC;\r\n\r\n      // 8. If byte is in the range 0x81 to 0xFE, set gb18030 first to\r\n      // byte and return continue.\r\n      if (inRange(bite, 0x81, 0xFE)) {\r\n        gb18030_first = bite;\r\n        return null;\r\n      }\r\n\r\n      // 9. Return error.\r\n      return decoderError(fatal);\r\n    };\r\n  }\r\n\r\n  // 11.2.2 gb18030 encoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Encoder}\r\n   * @param {{fatal: boolean}} options\r\n   * @param {boolean=} gbk_flag\r\n   */\r\n  function GB18030Encoder(options, gbk_flag) {\r\n    var fatal = options.fatal;\r\n    // gb18030's decoder has an associated gbk flag (initially unset).\r\n    /**\r\n     * @param {Stream} stream Input stream.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\r\n     */\r\n    this.handler = function(stream, code_point) {\r\n      // 1. If code point is end-of-stream, return finished.\r\n      if (code_point === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If code point is an ASCII code point, return a byte whose\r\n      // value is code point.\r\n      if (isASCIICodePoint(code_point))\r\n        return code_point;\r\n\r\n      // 3. If code point is U+E5E5, return error with code point.\r\n      if (code_point === 0xE5E5)\r\n        return encoderError(code_point);\r\n\r\n      // 4. If the gbk flag is set and code point is U+20AC, return\r\n      // byte 0x80.\r\n      if (gbk_flag && code_point === 0x20AC)\r\n        return 0x80;\r\n\r\n      // 5. Let pointer be the index pointer for code point in index\r\n      // gb18030.\r\n      var pointer = indexPointerFor(code_point, index('gb18030'));\r\n\r\n      // 6. If pointer is not null, run these substeps:\r\n      if (pointer !== null) {\r\n\r\n        // 1. Let lead be floor(pointer / 190) + 0x81.\r\n        var lead = floor(pointer / 190) + 0x81;\r\n\r\n        // 2. Let trail be pointer % 190.\r\n        var trail = pointer % 190;\r\n\r\n        // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\r\n        var offset = trail < 0x3F ? 0x40 : 0x41;\r\n\r\n        // 4. Return two bytes whose values are lead and trail + offset.\r\n        return [lead, trail + offset];\r\n      }\r\n\r\n      // 7. If gbk flag is set, return error with code point.\r\n      if (gbk_flag)\r\n        return encoderError(code_point);\r\n\r\n      // 8. Set pointer to the index gb18030 ranges pointer for code\r\n      // point.\r\n      pointer = indexGB18030RangesPointerFor(code_point);\r\n\r\n      // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\r\n      var byte1 = floor(pointer / 10 / 126 / 10);\r\n\r\n      // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\r\n      pointer = pointer - byte1 * 10 * 126 * 10;\r\n\r\n      // 11. Let byte2 be floor(pointer / 10 / 126).\r\n      var byte2 = floor(pointer / 10 / 126);\r\n\r\n      // 12. Set pointer to pointer − byte2 × 10 × 126.\r\n      pointer = pointer - byte2 * 10 * 126;\r\n\r\n      // 13. Let byte3 be floor(pointer / 10).\r\n      var byte3 = floor(pointer / 10);\r\n\r\n      // 14. Let byte4 be pointer − byte3 × 10.\r\n      var byte4 = pointer - byte3 * 10;\r\n\r\n      // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\r\n      // 0x30, byte3 + 0x81, byte4 + 0x30.\r\n      return [byte1 + 0x81,\r\n              byte2 + 0x30,\r\n              byte3 + 0x81,\r\n              byte4 + 0x30];\r\n    };\r\n  }\r\n\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['gb18030'] = function(options) {\r\n    return new GB18030Encoder(options);\r\n  };\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['gb18030'] = function(options) {\r\n    return new GB18030Decoder(options);\r\n  };\r\n\r\n\r\n  //\r\n  // 12. Legacy multi-byte Chinese (traditional) encodings\r\n  //\r\n\r\n  // 12.1 big5\r\n\r\n  // 12.1.1 big5 decoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Decoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function Big5Decoder(options) {\r\n    var fatal = options.fatal;\r\n    // big5's decoder has an associated big5 lead (initially 0x00).\r\n    var /** @type {number} */ big5_lead = 0x00;\r\n\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point.\r\n     */\r\n    this.handler = function(stream, bite) {\r\n      // 1. If byte is end-of-stream and big5 lead is not 0x00, set\r\n      // big5 lead to 0x00 and return error.\r\n      if (bite === end_of_stream && big5_lead !== 0x00) {\r\n        big5_lead = 0x00;\r\n        return decoderError(fatal);\r\n      }\r\n\r\n      // 2. If byte is end-of-stream and big5 lead is 0x00, return\r\n      // finished.\r\n      if (bite === end_of_stream && big5_lead === 0x00)\r\n        return finished;\r\n\r\n      // 3. If big5 lead is not 0x00, let lead be big5 lead, let\r\n      // pointer be null, set big5 lead to 0x00, and then run these\r\n      // substeps:\r\n      if (big5_lead !== 0x00) {\r\n        var lead = big5_lead;\r\n        var pointer = null;\r\n        big5_lead = 0x00;\r\n\r\n        // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\r\n        // otherwise.\r\n        var offset = bite < 0x7F ? 0x40 : 0x62;\r\n\r\n        // 2. If byte is in the range 0x40 to 0x7E or 0xA1 to 0xFE,\r\n        // set pointer to (lead − 0x81) × 157 + (byte − offset).\r\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))\r\n          pointer = (lead - 0x81) * 157 + (bite - offset);\r\n\r\n        // 3. If there is a row in the table below whose first column\r\n        // is pointer, return the two code points listed in its second\r\n        // column\r\n        // Pointer | Code points\r\n        // --------+--------------\r\n        // 1133    | U+00CA U+0304\r\n        // 1135    | U+00CA U+030C\r\n        // 1164    | U+00EA U+0304\r\n        // 1166    | U+00EA U+030C\r\n        switch (pointer) {\r\n          case 1133: return [0x00CA, 0x0304];\r\n          case 1135: return [0x00CA, 0x030C];\r\n          case 1164: return [0x00EA, 0x0304];\r\n          case 1166: return [0x00EA, 0x030C];\r\n        }\r\n\r\n        // 4. Let code point be null if pointer is null and the index\r\n        // code point for pointer in index big5 otherwise.\r\n        var code_point = (pointer === null) ? null :\r\n            indexCodePointFor(pointer, index('big5'));\r\n\r\n        // 5. If code point is null and byte is an ASCII byte, prepend\r\n        // byte to stream.\r\n        if (code_point === null && isASCIIByte(bite))\r\n          stream.prepend(bite);\r\n\r\n        // 6. If code point is null, return error.\r\n        if (code_point === null)\r\n          return decoderError(fatal);\r\n\r\n        // 7. Return a code point whose value is code point.\r\n        return code_point;\r\n      }\r\n\r\n      // 4. If byte is an ASCII byte, return a code point whose value\r\n      // is byte.\r\n      if (isASCIIByte(bite))\r\n        return bite;\r\n\r\n      // 5. If byte is in the range 0x81 to 0xFE, set big5 lead to\r\n      // byte and return continue.\r\n      if (inRange(bite, 0x81, 0xFE)) {\r\n        big5_lead = bite;\r\n        return null;\r\n      }\r\n\r\n      // 6. Return error.\r\n      return decoderError(fatal);\r\n    };\r\n  }\r\n\r\n  // 12.1.2 big5 encoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Encoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function Big5Encoder(options) {\r\n    var fatal = options.fatal;\r\n    /**\r\n     * @param {Stream} stream Input stream.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\r\n     */\r\n    this.handler = function(stream, code_point) {\r\n      // 1. If code point is end-of-stream, return finished.\r\n      if (code_point === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If code point is an ASCII code point, return a byte whose\r\n      // value is code point.\r\n      if (isASCIICodePoint(code_point))\r\n        return code_point;\r\n\r\n      // 3. Let pointer be the index big5 pointer for code point.\r\n      var pointer = indexBig5PointerFor(code_point);\r\n\r\n      // 4. If pointer is null, return error with code point.\r\n      if (pointer === null)\r\n        return encoderError(code_point);\r\n\r\n      // 5. Let lead be floor(pointer / 157) + 0x81.\r\n      var lead = floor(pointer / 157) + 0x81;\r\n\r\n      // 6. If lead is less than 0xA1, return error with code point.\r\n      if (lead < 0xA1)\r\n        return encoderError(code_point);\r\n\r\n      // 7. Let trail be pointer % 157.\r\n      var trail = pointer % 157;\r\n\r\n      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\r\n      // otherwise.\r\n      var offset = trail < 0x3F ? 0x40 : 0x62;\r\n\r\n      // Return two bytes whose values are lead and trail + offset.\r\n      return [lead, trail + offset];\r\n    };\r\n  }\r\n\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['Big5'] = function(options) {\r\n    return new Big5Encoder(options);\r\n  };\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['Big5'] = function(options) {\r\n    return new Big5Decoder(options);\r\n  };\r\n\r\n\r\n  //\r\n  // 13. Legacy multi-byte Japanese encodings\r\n  //\r\n\r\n  // 13.1 euc-jp\r\n\r\n  // 13.1.1 euc-jp decoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Decoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function EUCJPDecoder(options) {\r\n    var fatal = options.fatal;\r\n\r\n    // euc-jp's decoder has an associated euc-jp jis0212 flag\r\n    // (initially unset) and euc-jp lead (initially 0x00).\r\n    var /** @type {boolean} */ eucjp_jis0212_flag = false,\r\n        /** @type {number} */ eucjp_lead = 0x00;\r\n\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point.\r\n     */\r\n    this.handler = function(stream, bite) {\r\n      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\r\n      // euc-jp lead to 0x00, and return error.\r\n      if (bite === end_of_stream && eucjp_lead !== 0x00) {\r\n        eucjp_lead = 0x00;\r\n        return decoderError(fatal);\r\n      }\r\n\r\n      // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\r\n      // finished.\r\n      if (bite === end_of_stream && eucjp_lead === 0x00)\r\n        return finished;\r\n\r\n      // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\r\n      // 0xDF, set euc-jp lead to 0x00 and return a code point whose\r\n      // value is 0xFF61 + byte − 0xA1.\r\n      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\r\n        eucjp_lead = 0x00;\r\n        return 0xFF61 + bite - 0xA1;\r\n      }\r\n\r\n      // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\r\n      // 0xFE, set the euc-jp jis0212 flag, set euc-jp lead to byte,\r\n      // and return continue.\r\n      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\r\n        eucjp_jis0212_flag = true;\r\n        eucjp_lead = bite;\r\n        return null;\r\n      }\r\n\r\n      // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\r\n      // euc-jp lead to 0x00, and run these substeps:\r\n      if (eucjp_lead !== 0x00) {\r\n        var lead = eucjp_lead;\r\n        eucjp_lead = 0x00;\r\n\r\n        // 1. Let code point be null.\r\n        var code_point = null;\r\n\r\n        // 2. If lead and byte are both in the range 0xA1 to 0xFE, set\r\n        // code point to the index code point for (lead − 0xA1) × 94 +\r\n        // byte − 0xA1 in index jis0208 if the euc-jp jis0212 flag is\r\n        // unset and in index jis0212 otherwise.\r\n        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\r\n          code_point = indexCodePointFor(\r\n            (lead - 0xA1) * 94 + (bite - 0xA1),\r\n            index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\r\n        }\r\n\r\n        // 3. Unset the euc-jp jis0212 flag.\r\n        eucjp_jis0212_flag = false;\r\n\r\n        // 4. If byte is not in the range 0xA1 to 0xFE, prepend byte\r\n        // to stream.\r\n        if (!inRange(bite, 0xA1, 0xFE))\r\n          stream.prepend(bite);\r\n\r\n        // 5. If code point is null, return error.\r\n        if (code_point === null)\r\n          return decoderError(fatal);\r\n\r\n        // 6. Return a code point whose value is code point.\r\n        return code_point;\r\n      }\r\n\r\n      // 6. If byte is an ASCII byte, return a code point whose value\r\n      // is byte.\r\n      if (isASCIIByte(bite))\r\n        return bite;\r\n\r\n      // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, set\r\n      // euc-jp lead to byte and return continue.\r\n      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\r\n        eucjp_lead = bite;\r\n        return null;\r\n      }\r\n\r\n      // 8. Return error.\r\n      return decoderError(fatal);\r\n    };\r\n  }\r\n\r\n  // 13.1.2 euc-jp encoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Encoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function EUCJPEncoder(options) {\r\n    var fatal = options.fatal;\r\n    /**\r\n     * @param {Stream} stream Input stream.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\r\n     */\r\n    this.handler = function(stream, code_point) {\r\n      // 1. If code point is end-of-stream, return finished.\r\n      if (code_point === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If code point is an ASCII code point, return a byte whose\r\n      // value is code point.\r\n      if (isASCIICodePoint(code_point))\r\n        return code_point;\r\n\r\n      // 3. If code point is U+00A5, return byte 0x5C.\r\n      if (code_point === 0x00A5)\r\n        return 0x5C;\r\n\r\n      // 4. If code point is U+203E, return byte 0x7E.\r\n      if (code_point === 0x203E)\r\n        return 0x7E;\r\n\r\n      // 5. If code point is in the range U+FF61 to U+FF9F, return two\r\n      // bytes whose values are 0x8E and code point − 0xFF61 + 0xA1.\r\n      if (inRange(code_point, 0xFF61, 0xFF9F))\r\n        return [0x8E, code_point - 0xFF61 + 0xA1];\r\n\r\n      // 6. If code point is U+2212, set it to U+FF0D.\r\n      if (code_point === 0x2212)\r\n        code_point = 0xFF0D;\r\n\r\n      // 7. Let pointer be the index pointer for code point in index\r\n      // jis0208.\r\n      var pointer = indexPointerFor(code_point, index('jis0208'));\r\n\r\n      // 8. If pointer is null, return error with code point.\r\n      if (pointer === null)\r\n        return encoderError(code_point);\r\n\r\n      // 9. Let lead be floor(pointer / 94) + 0xA1.\r\n      var lead = floor(pointer / 94) + 0xA1;\r\n\r\n      // 10. Let trail be pointer % 94 + 0xA1.\r\n      var trail = pointer % 94 + 0xA1;\r\n\r\n      // 11. Return two bytes whose values are lead and trail.\r\n      return [lead, trail];\r\n    };\r\n  }\r\n\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['EUC-JP'] = function(options) {\r\n    return new EUCJPEncoder(options);\r\n  };\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['EUC-JP'] = function(options) {\r\n    return new EUCJPDecoder(options);\r\n  };\r\n\r\n  // 13.2 iso-2022-jp\r\n\r\n  // 13.2.1 iso-2022-jp decoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Decoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function ISO2022JPDecoder(options) {\r\n    var fatal = options.fatal;\r\n    /** @enum */\r\n    var states = {\r\n      ASCII: 0,\r\n      Roman: 1,\r\n      Katakana: 2,\r\n      LeadByte: 3,\r\n      TrailByte: 4,\r\n      EscapeStart: 5,\r\n      Escape: 6\r\n    };\r\n    // iso-2022-jp's decoder has an associated iso-2022-jp decoder\r\n    // state (initially ASCII), iso-2022-jp decoder output state\r\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\r\n    // iso-2022-jp output flag (initially unset).\r\n    var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,\r\n        /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,\r\n        /** @type {number} */ iso2022jp_lead = 0x00,\r\n        /** @type {boolean} */ iso2022jp_output_flag = false;\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point.\r\n     */\r\n    this.handler = function(stream, bite) {\r\n      // switching on iso-2022-jp decoder state:\r\n      switch (iso2022jp_decoder_state) {\r\n      default:\r\n      case states.ASCII:\r\n        // ASCII\r\n        // Based on byte:\r\n\r\n        // 0x1B\r\n        if (bite === 0x1B) {\r\n          // Set iso-2022-jp decoder state to escape start and return\r\n          // continue.\r\n          iso2022jp_decoder_state = states.EscapeStart;\r\n          return null;\r\n        }\r\n\r\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\r\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E\r\n            && bite !== 0x0F && bite !== 0x1B) {\r\n          // Unset the iso-2022-jp output flag and return a code point\r\n          // whose value is byte.\r\n          iso2022jp_output_flag = false;\r\n          return bite;\r\n        }\r\n\r\n        // end-of-stream\r\n        if (bite === end_of_stream) {\r\n          // Return finished.\r\n          return finished;\r\n        }\r\n\r\n        // Otherwise\r\n        // Unset the iso-2022-jp output flag and return error.\r\n        iso2022jp_output_flag = false;\r\n        return decoderError(fatal);\r\n\r\n      case states.Roman:\r\n        // Roman\r\n        // Based on byte:\r\n\r\n        // 0x1B\r\n        if (bite === 0x1B) {\r\n          // Set iso-2022-jp decoder state to escape start and return\r\n          // continue.\r\n          iso2022jp_decoder_state = states.EscapeStart;\r\n          return null;\r\n        }\r\n\r\n        // 0x5C\r\n        if (bite === 0x5C) {\r\n          // Unset the iso-2022-jp output flag and return code point\r\n          // U+00A5.\r\n          iso2022jp_output_flag = false;\r\n          return 0x00A5;\r\n        }\r\n\r\n        // 0x7E\r\n        if (bite === 0x7E) {\r\n          // Unset the iso-2022-jp output flag and return code point\r\n          // U+203E.\r\n          iso2022jp_output_flag = false;\r\n          return 0x203E;\r\n        }\r\n\r\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\r\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F\r\n            && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\r\n          // Unset the iso-2022-jp output flag and return a code point\r\n          // whose value is byte.\r\n          iso2022jp_output_flag = false;\r\n          return bite;\r\n        }\r\n\r\n        // end-of-stream\r\n        if (bite === end_of_stream) {\r\n          // Return finished.\r\n          return finished;\r\n        }\r\n\r\n        // Otherwise\r\n        // Unset the iso-2022-jp output flag and return error.\r\n        iso2022jp_output_flag = false;\r\n        return decoderError(fatal);\r\n\r\n      case states.Katakana:\r\n        // Katakana\r\n        // Based on byte:\r\n\r\n        // 0x1B\r\n        if (bite === 0x1B) {\r\n          // Set iso-2022-jp decoder state to escape start and return\r\n          // continue.\r\n          iso2022jp_decoder_state = states.EscapeStart;\r\n          return null;\r\n        }\r\n\r\n        // 0x21 to 0x5F\r\n        if (inRange(bite, 0x21, 0x5F)) {\r\n          // Unset the iso-2022-jp output flag and return a code point\r\n          // whose value is 0xFF61 + byte − 0x21.\r\n          iso2022jp_output_flag = false;\r\n          return 0xFF61 + bite - 0x21;\r\n        }\r\n\r\n        // end-of-stream\r\n        if (bite === end_of_stream) {\r\n          // Return finished.\r\n          return finished;\r\n        }\r\n\r\n        // Otherwise\r\n        // Unset the iso-2022-jp output flag and return error.\r\n        iso2022jp_output_flag = false;\r\n        return decoderError(fatal);\r\n\r\n      case states.LeadByte:\r\n        // Lead byte\r\n        // Based on byte:\r\n\r\n        // 0x1B\r\n        if (bite === 0x1B) {\r\n          // Set iso-2022-jp decoder state to escape start and return\r\n          // continue.\r\n          iso2022jp_decoder_state = states.EscapeStart;\r\n          return null;\r\n        }\r\n\r\n        // 0x21 to 0x7E\r\n        if (inRange(bite, 0x21, 0x7E)) {\r\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\r\n          // to byte, iso-2022-jp decoder state to trail byte, and\r\n          // return continue.\r\n          iso2022jp_output_flag = false;\r\n          iso2022jp_lead = bite;\r\n          iso2022jp_decoder_state = states.TrailByte;\r\n          return null;\r\n        }\r\n\r\n        // end-of-stream\r\n        if (bite === end_of_stream) {\r\n          // Return finished.\r\n          return finished;\r\n        }\r\n\r\n        // Otherwise\r\n        // Unset the iso-2022-jp output flag and return error.\r\n        iso2022jp_output_flag = false;\r\n        return decoderError(fatal);\r\n\r\n      case states.TrailByte:\r\n        // Trail byte\r\n        // Based on byte:\r\n\r\n        // 0x1B\r\n        if (bite === 0x1B) {\r\n          // Set iso-2022-jp decoder state to escape start and return\r\n          // continue.\r\n          iso2022jp_decoder_state = states.EscapeStart;\r\n          return decoderError(fatal);\r\n        }\r\n\r\n        // 0x21 to 0x7E\r\n        if (inRange(bite, 0x21, 0x7E)) {\r\n          // 1. Set the iso-2022-jp decoder state to lead byte.\r\n          iso2022jp_decoder_state = states.LeadByte;\r\n\r\n          // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\r\n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\r\n\r\n          // 3. Let code point be the index code point for pointer in\r\n          // index jis0208.\r\n          var code_point = indexCodePointFor(pointer, index('jis0208'));\r\n\r\n          // 4. If code point is null, return error.\r\n          if (code_point === null)\r\n            return decoderError(fatal);\r\n\r\n          // 5. Return a code point whose value is code point.\r\n          return code_point;\r\n        }\r\n\r\n        // end-of-stream\r\n        if (bite === end_of_stream) {\r\n          // Set the iso-2022-jp decoder state to lead byte, prepend\r\n          // byte to stream, and return error.\r\n          iso2022jp_decoder_state = states.LeadByte;\r\n          stream.prepend(bite);\r\n          return decoderError(fatal);\r\n        }\r\n\r\n        // Otherwise\r\n        // Set iso-2022-jp decoder state to lead byte and return\r\n        // error.\r\n        iso2022jp_decoder_state = states.LeadByte;\r\n        return decoderError(fatal);\r\n\r\n      case states.EscapeStart:\r\n        // Escape start\r\n\r\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\r\n        // byte, iso-2022-jp decoder state to escape, and return\r\n        // continue.\r\n        if (bite === 0x24 || bite === 0x28) {\r\n          iso2022jp_lead = bite;\r\n          iso2022jp_decoder_state = states.Escape;\r\n          return null;\r\n        }\r\n\r\n        // 2. Prepend byte to stream.\r\n        stream.prepend(bite);\r\n\r\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\r\n        // decoder state to iso-2022-jp decoder output state, and\r\n        // return error.\r\n        iso2022jp_output_flag = false;\r\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\r\n        return decoderError(fatal);\r\n\r\n      case states.Escape:\r\n        // Escape\r\n\r\n        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\r\n        // 0x00.\r\n        var lead = iso2022jp_lead;\r\n        iso2022jp_lead = 0x00;\r\n\r\n        // 2. Let state be null.\r\n        var state = null;\r\n\r\n        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\r\n        if (lead === 0x28 && bite === 0x42)\r\n          state = states.ASCII;\r\n\r\n        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\r\n        if (lead === 0x28 && bite === 0x4A)\r\n          state = states.Roman;\r\n\r\n        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\r\n        if (lead === 0x28 && bite === 0x49)\r\n          state = states.Katakana;\r\n\r\n        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\r\n        // state to lead byte.\r\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42))\r\n          state = states.LeadByte;\r\n\r\n        // 7. If state is non-null, run these substeps:\r\n        if (state !== null) {\r\n          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\r\n          // output state to states.\r\n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\r\n\r\n          // 2. Let output flag be the iso-2022-jp output flag.\r\n          var output_flag = iso2022jp_output_flag;\r\n\r\n          // 3. Set the iso-2022-jp output flag.\r\n          iso2022jp_output_flag = true;\r\n\r\n          // 4. Return continue, if output flag is unset, and error\r\n          // otherwise.\r\n          return !output_flag ? null : decoderError(fatal);\r\n        }\r\n\r\n        // 8. Prepend lead and byte to stream.\r\n        stream.prepend([lead, bite]);\r\n\r\n        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\r\n        // decoder state to iso-2022-jp decoder output state and\r\n        // return error.\r\n        iso2022jp_output_flag = false;\r\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\r\n        return decoderError(fatal);\r\n      }\r\n    };\r\n  }\r\n\r\n  // 13.2.2 iso-2022-jp encoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Encoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function ISO2022JPEncoder(options) {\r\n    var fatal = options.fatal;\r\n    // iso-2022-jp's encoder has an associated iso-2022-jp encoder\r\n    // state which is one of ASCII, Roman, and jis0208 (initially\r\n    // ASCII).\r\n    /** @enum */\r\n    var states = {\r\n      ASCII: 0,\r\n      Roman: 1,\r\n      jis0208: 2\r\n    };\r\n    var /** @type {number} */ iso2022jp_state = states.ASCII;\r\n    /**\r\n     * @param {Stream} stream Input stream.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\r\n     */\r\n    this.handler = function(stream, code_point) {\r\n      // 1. If code point is end-of-stream and iso-2022-jp encoder\r\n      // state is not ASCII, prepend code point to stream, set\r\n      // iso-2022-jp encoder state to ASCII, and return three bytes\r\n      // 0x1B 0x28 0x42.\r\n      if (code_point === end_of_stream &&\r\n          iso2022jp_state !== states.ASCII) {\r\n        stream.prepend(code_point);\r\n        iso2022jp_state = states.ASCII;\r\n        return [0x1B, 0x28, 0x42];\r\n      }\r\n\r\n      // 2. If code point is end-of-stream and iso-2022-jp encoder\r\n      // state is ASCII, return finished.\r\n      if (code_point === end_of_stream && iso2022jp_state === states.ASCII)\r\n        return finished;\r\n\r\n      // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\r\n      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\r\n      if ((iso2022jp_state === states.ASCII ||\r\n           iso2022jp_state === states.Roman) &&\r\n          (code_point === 0x000E || code_point === 0x000F ||\r\n           code_point === 0x001B)) {\r\n        return encoderError(0xFFFD);\r\n      }\r\n\r\n      // 4. If iso-2022-jp encoder state is ASCII and code point is an\r\n      // ASCII code point, return a byte whose value is code point.\r\n      if (iso2022jp_state === states.ASCII &&\r\n          isASCIICodePoint(code_point))\r\n        return code_point;\r\n\r\n      // 5. If iso-2022-jp encoder state is Roman and code point is an\r\n      // ASCII code point, excluding U+005C and U+007E, or is U+00A5\r\n      // or U+203E, run these substeps:\r\n      if (iso2022jp_state === states.Roman &&\r\n          ((isASCIICodePoint(code_point) &&\r\n           code_point !== 0x005C && code_point !== 0x007E) ||\r\n          (code_point == 0x00A5 || code_point == 0x203E))) {\r\n\r\n        // 1. If code point is an ASCII code point, return a byte\r\n        // whose value is code point.\r\n        if (isASCIICodePoint(code_point))\r\n          return code_point;\r\n\r\n        // 2. If code point is U+00A5, return byte 0x5C.\r\n        if (code_point === 0x00A5)\r\n          return 0x5C;\r\n\r\n        // 3. If code point is U+203E, return byte 0x7E.\r\n        if (code_point === 0x203E)\r\n          return 0x7E;\r\n      }\r\n\r\n      // 6. If code point is an ASCII code point, and iso-2022-jp\r\n      // encoder state is not ASCII, prepend code point to stream, set\r\n      // iso-2022-jp encoder state to ASCII, and return three bytes\r\n      // 0x1B 0x28 0x42.\r\n      if (isASCIICodePoint(code_point) &&\r\n          iso2022jp_state !== states.ASCII) {\r\n        stream.prepend(code_point);\r\n        iso2022jp_state = states.ASCII;\r\n        return [0x1B, 0x28, 0x42];\r\n      }\r\n\r\n      // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\r\n      // encoder state is not Roman, prepend code point to stream, set\r\n      // iso-2022-jp encoder state to Roman, and return three bytes\r\n      // 0x1B 0x28 0x4A.\r\n      if ((code_point === 0x00A5 || code_point === 0x203E) &&\r\n          iso2022jp_state !== states.Roman) {\r\n        stream.prepend(code_point);\r\n        iso2022jp_state = states.Roman;\r\n        return [0x1B, 0x28, 0x4A];\r\n      }\r\n\r\n      // 8. If code point is U+2212, set it to U+FF0D.\r\n      if (code_point === 0x2212)\r\n        code_point = 0xFF0D;\r\n\r\n      // 9. Let pointer be the index pointer for code point in index\r\n      // jis0208.\r\n      var pointer = indexPointerFor(code_point, index('jis0208'));\r\n\r\n      // 10. If pointer is null, return error with code point.\r\n      if (pointer === null)\r\n        return encoderError(code_point);\r\n\r\n      // 11. If iso-2022-jp encoder state is not jis0208, prepend code\r\n      // point to stream, set iso-2022-jp encoder state to jis0208,\r\n      // and return three bytes 0x1B 0x24 0x42.\r\n      if (iso2022jp_state !== states.jis0208) {\r\n        stream.prepend(code_point);\r\n        iso2022jp_state = states.jis0208;\r\n        return [0x1B, 0x24, 0x42];\r\n      }\r\n\r\n      // 12. Let lead be floor(pointer / 94) + 0x21.\r\n      var lead = floor(pointer / 94) + 0x21;\r\n\r\n      // 13. Let trail be pointer % 94 + 0x21.\r\n      var trail = pointer % 94 + 0x21;\r\n\r\n      // 14. Return two bytes whose values are lead and trail.\r\n      return [lead, trail];\r\n    };\r\n  }\r\n\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['ISO-2022-JP'] = function(options) {\r\n    return new ISO2022JPEncoder(options);\r\n  };\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['ISO-2022-JP'] = function(options) {\r\n    return new ISO2022JPDecoder(options);\r\n  };\r\n\r\n  // 13.3 shift_jis\r\n\r\n  // 13.3.1 shift_jis decoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Decoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function ShiftJISDecoder(options) {\r\n    var fatal = options.fatal;\r\n    // shift_jis's decoder has an associated shift_jis lead (initially\r\n    // 0x00).\r\n    var /** @type {number} */ shiftjis_lead = 0x00;\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point.\r\n     */\r\n    this.handler = function(stream, bite) {\r\n      // 1. If byte is end-of-stream and shift_jis lead is not 0x00,\r\n      // set shift_jis lead to 0x00 and return error.\r\n      if (bite === end_of_stream && shiftjis_lead !== 0x00) {\r\n        shiftjis_lead = 0x00;\r\n        return decoderError(fatal);\r\n      }\r\n\r\n      // 2. If byte is end-of-stream and shift_jis lead is 0x00,\r\n      // return finished.\r\n      if (bite === end_of_stream && shiftjis_lead === 0x00)\r\n        return finished;\r\n\r\n      // 3. If shift_jis lead is not 0x00, let lead be shift_jis lead,\r\n      // let pointer be null, set shift_jis lead to 0x00, and then run\r\n      // these substeps:\r\n      if (shiftjis_lead !== 0x00) {\r\n        var lead = shiftjis_lead;\r\n        var pointer = null;\r\n        shiftjis_lead = 0x00;\r\n\r\n        // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\r\n        // otherwise.\r\n        var offset = (bite < 0x7F) ? 0x40 : 0x41;\r\n\r\n        // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\r\n        // 0xC1 otherwise.\r\n        var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;\r\n\r\n        // 3. If byte is in the range 0x40 to 0x7E or 0x80 to 0xFC,\r\n        // set pointer to (lead − lead offset) × 188 + byte − offset.\r\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))\r\n          pointer = (lead - lead_offset) * 188 + bite - offset;\r\n\r\n        // 4. Let code point be null, if pointer is null, and the\r\n        // index code point for pointer in index jis0208 otherwise.\r\n        var code_point = (pointer === null) ? null :\r\n              indexCodePointFor(pointer, index('jis0208'));\r\n\r\n        // 5. If code point is null and pointer is in the range 8836\r\n        // to 10528, return a code point whose value is 0xE000 +\r\n        // pointer − 8836.\r\n        if (code_point === null && pointer !== null &&\r\n            inRange(pointer, 8836, 10528))\r\n          return 0xE000 + pointer - 8836;\r\n\r\n        // 6. If code point is null and byte is an ASCII byte, prepend\r\n        // byte to stream.\r\n        if (code_point === null && isASCIIByte(bite))\r\n          stream.prepend(bite);\r\n\r\n        // 7. If code point is null, return error.\r\n        if (code_point === null)\r\n          return decoderError(fatal);\r\n\r\n        // 8. Return a code point whose value is code point.\r\n        return code_point;\r\n      }\r\n\r\n      // 4. If byte is an ASCII byte or 0x80, return a code point\r\n      // whose value is byte.\r\n      if (isASCIIByte(bite) || bite === 0x80)\r\n        return bite;\r\n\r\n      // 5. If byte is in the range 0xA1 to 0xDF, return a code point\r\n      // whose value is 0xFF61 + byte − 0xA1.\r\n      if (inRange(bite, 0xA1, 0xDF))\r\n        return 0xFF61 + bite - 0xA1;\r\n\r\n      // 6. If byte is in the range 0x81 to 0x9F or 0xE0 to 0xFC, set\r\n      // shift_jis lead to byte and return continue.\r\n      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\r\n        shiftjis_lead = bite;\r\n        return null;\r\n      }\r\n\r\n      // 7. Return error.\r\n      return decoderError(fatal);\r\n    };\r\n  }\r\n\r\n  // 13.3.2 shift_jis encoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Encoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function ShiftJISEncoder(options) {\r\n    var fatal = options.fatal;\r\n    /**\r\n     * @param {Stream} stream Input stream.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\r\n     */\r\n    this.handler = function(stream, code_point) {\r\n      // 1. If code point is end-of-stream, return finished.\r\n      if (code_point === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If code point is an ASCII code point or U+0080, return a\r\n      // byte whose value is code point.\r\n      if (isASCIICodePoint(code_point) || code_point === 0x0080)\r\n        return code_point;\r\n\r\n      // 3. If code point is U+00A5, return byte 0x5C.\r\n      if (code_point === 0x00A5)\r\n        return 0x5C;\r\n\r\n      // 4. If code point is U+203E, return byte 0x7E.\r\n      if (code_point === 0x203E)\r\n        return 0x7E;\r\n\r\n      // 5. If code point is in the range U+FF61 to U+FF9F, return a\r\n      // byte whose value is code point − 0xFF61 + 0xA1.\r\n      if (inRange(code_point, 0xFF61, 0xFF9F))\r\n        return code_point - 0xFF61 + 0xA1;\r\n\r\n      // 6. If code point is U+2212, set it to U+FF0D.\r\n      if (code_point === 0x2212)\r\n        code_point = 0xFF0D;\r\n\r\n      // 7. Let pointer be the index shift_jis pointer for code point.\r\n      var pointer = indexShiftJISPointerFor(code_point);\r\n\r\n      // 8. If pointer is null, return error with code point.\r\n      if (pointer === null)\r\n        return encoderError(code_point);\r\n\r\n      // 9. Let lead be floor(pointer / 188).\r\n      var lead = floor(pointer / 188);\r\n\r\n      // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\r\n      // 0xC1 otherwise.\r\n      var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1;\r\n\r\n      // 11. Let trail be pointer % 188.\r\n      var trail = pointer % 188;\r\n\r\n      // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\r\n      // otherwise.\r\n      var offset = (trail < 0x3F) ? 0x40 : 0x41;\r\n\r\n      // 13. Return two bytes whose values are lead + lead offset and\r\n      // trail + offset.\r\n      return [lead + lead_offset, trail + offset];\r\n    };\r\n  }\r\n\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['Shift_JIS'] = function(options) {\r\n    return new ShiftJISEncoder(options);\r\n  };\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['Shift_JIS'] = function(options) {\r\n    return new ShiftJISDecoder(options);\r\n  };\r\n\r\n  //\r\n  // 14. Legacy multi-byte Korean encodings\r\n  //\r\n\r\n  // 14.1 euc-kr\r\n\r\n  // 14.1.1 euc-kr decoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Decoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function EUCKRDecoder(options) {\r\n    var fatal = options.fatal;\r\n\r\n    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\r\n    var /** @type {number} */ euckr_lead = 0x00;\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point.\r\n     */\r\n    this.handler = function(stream, bite) {\r\n      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\r\n      // euc-kr lead to 0x00 and return error.\r\n      if (bite === end_of_stream && euckr_lead !== 0) {\r\n        euckr_lead = 0x00;\r\n        return decoderError(fatal);\r\n      }\r\n\r\n      // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\r\n      // finished.\r\n      if (bite === end_of_stream && euckr_lead === 0)\r\n        return finished;\r\n\r\n      // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\r\n      // pointer be null, set euc-kr lead to 0x00, and then run these\r\n      // substeps:\r\n      if (euckr_lead !== 0x00) {\r\n        var lead = euckr_lead;\r\n        var pointer = null;\r\n        euckr_lead = 0x00;\r\n\r\n        // 1. If byte is in the range 0x41 to 0xFE, set pointer to\r\n        // (lead − 0x81) × 190 + (byte − 0x41).\r\n        if (inRange(bite, 0x41, 0xFE))\r\n          pointer = (lead - 0x81) * 190 + (bite - 0x41);\r\n\r\n        // 2. Let code point be null, if pointer is null, and the\r\n        // index code point for pointer in index euc-kr otherwise.\r\n        var code_point = (pointer === null)\r\n              ? null : indexCodePointFor(pointer, index('euc-kr'));\r\n\r\n        // 3. If code point is null and byte is an ASCII byte, prepend\r\n        // byte to stream.\r\n        if (pointer === null && isASCIIByte(bite))\r\n          stream.prepend(bite);\r\n\r\n        // 4. If code point is null, return error.\r\n        if (code_point === null)\r\n          return decoderError(fatal);\r\n\r\n        // 5. Return a code point whose value is code point.\r\n        return code_point;\r\n      }\r\n\r\n      // 4. If byte is an ASCII byte, return a code point whose value\r\n      // is byte.\r\n      if (isASCIIByte(bite))\r\n        return bite;\r\n\r\n      // 5. If byte is in the range 0x81 to 0xFE, set euc-kr lead to\r\n      // byte and return continue.\r\n      if (inRange(bite, 0x81, 0xFE)) {\r\n        euckr_lead = bite;\r\n        return null;\r\n      }\r\n\r\n      // 6. Return error.\r\n      return decoderError(fatal);\r\n    };\r\n  }\r\n\r\n  // 14.1.2 euc-kr encoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Encoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function EUCKREncoder(options) {\r\n    var fatal = options.fatal;\r\n    /**\r\n     * @param {Stream} stream Input stream.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\r\n     */\r\n    this.handler = function(stream, code_point) {\r\n      // 1. If code point is end-of-stream, return finished.\r\n      if (code_point === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If code point is an ASCII code point, return a byte whose\r\n      // value is code point.\r\n      if (isASCIICodePoint(code_point))\r\n        return code_point;\r\n\r\n      // 3. Let pointer be the index pointer for code point in index\r\n      // euc-kr.\r\n      var pointer = indexPointerFor(code_point, index('euc-kr'));\r\n\r\n      // 4. If pointer is null, return error with code point.\r\n      if (pointer === null)\r\n        return encoderError(code_point);\r\n\r\n      // 5. Let lead be floor(pointer / 190) + 0x81.\r\n      var lead = floor(pointer / 190) + 0x81;\r\n\r\n      // 6. Let trail be pointer % 190 + 0x41.\r\n      var trail = (pointer % 190) + 0x41;\r\n\r\n      // 7. Return two bytes whose values are lead and trail.\r\n      return [lead, trail];\r\n    };\r\n  }\r\n\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['EUC-KR'] = function(options) {\r\n    return new EUCKREncoder(options);\r\n  };\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['EUC-KR'] = function(options) {\r\n    return new EUCKRDecoder(options);\r\n  };\r\n\r\n\r\n  //\r\n  // 15. Legacy miscellaneous encodings\r\n  //\r\n\r\n  // 15.1 replacement\r\n\r\n  // Not needed - API throws RangeError\r\n\r\n  // 15.2 Common infrastructure for utf-16be and utf-16le\r\n\r\n  /**\r\n   * @param {number} code_unit\r\n   * @param {boolean} utf16be\r\n   * @return {!Array.<number>} bytes\r\n   */\r\n  function convertCodeUnitToBytes(code_unit, utf16be) {\r\n    // 1. Let byte1 be code unit >> 8.\r\n    var byte1 = code_unit >> 8;\r\n\r\n    // 2. Let byte2 be code unit & 0x00FF.\r\n    var byte2 = code_unit & 0x00FF;\r\n\r\n    // 3. Then return the bytes in order:\r\n        // utf-16be flag is set: byte1, then byte2.\r\n    if (utf16be)\r\n      return [byte1, byte2];\r\n    // utf-16be flag is unset: byte2, then byte1.\r\n    return [byte2, byte1];\r\n  }\r\n\r\n  // 15.2.1 shared utf-16 decoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Decoder}\r\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function UTF16Decoder(utf16_be, options) {\r\n    var fatal = options.fatal;\r\n    var /** @type {?number} */ utf16_lead_byte = null,\r\n        /** @type {?number} */ utf16_lead_surrogate = null;\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point.\r\n     */\r\n    this.handler = function(stream, bite) {\r\n      // 1. If byte is end-of-stream and either utf-16 lead byte or\r\n      // utf-16 lead surrogate is not null, set utf-16 lead byte and\r\n      // utf-16 lead surrogate to null, and return error.\r\n      if (bite === end_of_stream && (utf16_lead_byte !== null ||\r\n                                utf16_lead_surrogate !== null)) {\r\n        return decoderError(fatal);\r\n      }\r\n\r\n      // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\r\n      // lead surrogate are null, return finished.\r\n      if (bite === end_of_stream && utf16_lead_byte === null &&\r\n          utf16_lead_surrogate === null) {\r\n        return finished;\r\n      }\r\n\r\n      // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\r\n      // and return continue.\r\n      if (utf16_lead_byte === null) {\r\n        utf16_lead_byte = bite;\r\n        return null;\r\n      }\r\n\r\n      // 4. Let code unit be the result of:\r\n      var code_unit;\r\n      if (utf16_be) {\r\n        // utf-16be decoder flag is set\r\n        //   (utf-16 lead byte << 8) + byte.\r\n        code_unit = (utf16_lead_byte << 8) + bite;\r\n      } else {\r\n        // utf-16be decoder flag is unset\r\n        //   (byte << 8) + utf-16 lead byte.\r\n        code_unit = (bite << 8) + utf16_lead_byte;\r\n      }\r\n      // Then set utf-16 lead byte to null.\r\n      utf16_lead_byte = null;\r\n\r\n      // 5. If utf-16 lead surrogate is not null, let lead surrogate\r\n      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\r\n      // and then run these substeps:\r\n      if (utf16_lead_surrogate !== null) {\r\n        var lead_surrogate = utf16_lead_surrogate;\r\n        utf16_lead_surrogate = null;\r\n\r\n        // 1. If code unit is in the range U+DC00 to U+DFFF, return a\r\n        // code point whose value is 0x10000 + ((lead surrogate −\r\n        // 0xD800) << 10) + (code unit − 0xDC00).\r\n        if (inRange(code_unit, 0xDC00, 0xDFFF)) {\r\n          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +\r\n              (code_unit - 0xDC00);\r\n        }\r\n\r\n        // 2. Prepend the sequence resulting of converting code unit\r\n        // to bytes using utf-16be decoder flag to stream and return\r\n        // error.\r\n        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\r\n        return decoderError(fatal);\r\n      }\r\n\r\n      // 6. If code unit is in the range U+D800 to U+DBFF, set utf-16\r\n      // lead surrogate to code unit and return continue.\r\n      if (inRange(code_unit, 0xD800, 0xDBFF)) {\r\n        utf16_lead_surrogate = code_unit;\r\n        return null;\r\n      }\r\n\r\n      // 7. If code unit is in the range U+DC00 to U+DFFF, return\r\n      // error.\r\n      if (inRange(code_unit, 0xDC00, 0xDFFF))\r\n        return decoderError(fatal);\r\n\r\n      // 8. Return code point code unit.\r\n      return code_unit;\r\n    };\r\n  }\r\n\r\n  // 15.2.2 shared utf-16 encoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Encoder}\r\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function UTF16Encoder(utf16_be, options) {\r\n    var fatal = options.fatal;\r\n    /**\r\n     * @param {Stream} stream Input stream.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\r\n     */\r\n    this.handler = function(stream, code_point) {\r\n      // 1. If code point is end-of-stream, return finished.\r\n      if (code_point === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If code point is in the range U+0000 to U+FFFF, return the\r\n      // sequence resulting of converting code point to bytes using\r\n      // utf-16be encoder flag.\r\n      if (inRange(code_point, 0x0000, 0xFFFF))\r\n        return convertCodeUnitToBytes(code_point, utf16_be);\r\n\r\n      // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\r\n      // converted to bytes using utf-16be encoder flag.\r\n      var lead = convertCodeUnitToBytes(\r\n        ((code_point - 0x10000) >> 10) + 0xD800, utf16_be);\r\n\r\n      // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\r\n      // converted to bytes using utf-16be encoder flag.\r\n      var trail = convertCodeUnitToBytes(\r\n        ((code_point - 0x10000) & 0x3FF) + 0xDC00, utf16_be);\r\n\r\n      // 5. Return a byte sequence of lead followed by trail.\r\n      return lead.concat(trail);\r\n    };\r\n  }\r\n\r\n  // 15.3 utf-16be\r\n  // 15.3.1 utf-16be decoder\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['UTF-16BE'] = function(options) {\r\n    return new UTF16Encoder(true, options);\r\n  };\r\n  // 15.3.2 utf-16be encoder\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['UTF-16BE'] = function(options) {\r\n    return new UTF16Decoder(true, options);\r\n  };\r\n\r\n  // 15.4 utf-16le\r\n  // 15.4.1 utf-16le decoder\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['UTF-16LE'] = function(options) {\r\n    return new UTF16Encoder(false, options);\r\n  };\r\n  // 15.4.2 utf-16le encoder\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['UTF-16LE'] = function(options) {\r\n    return new UTF16Decoder(false, options);\r\n  };\r\n\r\n  // 15.5 x-user-defined\r\n\r\n  // 15.5.1 x-user-defined decoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Decoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function XUserDefinedDecoder(options) {\r\n    var fatal = options.fatal;\r\n    /**\r\n     * @param {Stream} stream The stream of bytes being decoded.\r\n     * @param {number} bite The next byte read from the stream.\r\n     * @return {?(number|!Array.<number>)} The next code point(s)\r\n     *     decoded, or null if not enough data exists in the input\r\n     *     stream to decode a complete code point.\r\n     */\r\n    this.handler = function(stream, bite) {\r\n      // 1. If byte is end-of-stream, return finished.\r\n      if (bite === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If byte is an ASCII byte, return a code point whose value\r\n      // is byte.\r\n      if (isASCIIByte(bite))\r\n        return bite;\r\n\r\n      // 3. Return a code point whose value is 0xF780 + byte − 0x80.\r\n      return 0xF780 + bite - 0x80;\r\n    };\r\n  }\r\n\r\n  // 15.5.2 x-user-defined encoder\r\n  /**\r\n   * @constructor\r\n   * @implements {Encoder}\r\n   * @param {{fatal: boolean}} options\r\n   */\r\n  function XUserDefinedEncoder(options) {\r\n    var fatal = options.fatal;\r\n    /**\r\n     * @param {Stream} stream Input stream.\r\n     * @param {number} code_point Next code point read from the stream.\r\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\r\n     */\r\n    this.handler = function(stream, code_point) {\r\n      // 1.If code point is end-of-stream, return finished.\r\n      if (code_point === end_of_stream)\r\n        return finished;\r\n\r\n      // 2. If code point is an ASCII code point, return a byte whose\r\n      // value is code point.\r\n      if (isASCIICodePoint(code_point))\r\n        return code_point;\r\n\r\n      // 3. If code point is in the range U+F780 to U+F7FF, return a\r\n      // byte whose value is code point − 0xF780 + 0x80.\r\n      if (inRange(code_point, 0xF780, 0xF7FF))\r\n        return code_point - 0xF780 + 0x80;\r\n\r\n      // 4. Return error with code point.\r\n      return encoderError(code_point);\r\n    };\r\n  }\r\n\r\n  /** @param {{fatal: boolean}} options */\r\n  encoders['x-user-defined'] = function(options) {\r\n    return new XUserDefinedEncoder(options);\r\n  };\r\n  /** @param {{fatal: boolean}} options */\r\n  decoders['x-user-defined'] = function(options) {\r\n    return new XUserDefinedDecoder(options);\r\n  };\r\n\r\n  if (!global['TextEncoder'])\r\n    global['TextEncoder'] = TextEncoder;\r\n  if (!global['TextDecoder'])\r\n    global['TextDecoder'] = TextDecoder;\r\n\r\n  if (typeof module !== \"undefined\" && module.exports) {\r\n    module.exports = {\r\n      TextEncoder: global['TextEncoder'],\r\n      TextDecoder: global['TextDecoder'],\r\n      EncodingIndexes: global[\"encoding-indexes\"]\r\n    };\r\n  }\r\n}(this));\r\n/* jshint ignore:end */\r\n\n// jshint freeze:false\r\n// jshint bitwise: false\r\n// jscs:disable\r\n/* jshint ignore:start */\r\n// taken from http://stackoverflow.com/a/27157351\r\n\r\n(function () {\r\n    // correctly serializes svg (and xml in general) content in IE\r\n    function serializeSvgContent(element) {\r\n        var result = '<' + element.nodeName;\r\n\r\n        // add in the element's attributes\r\n        for (var i = 0; i < element.attributes.length; i++) {\r\n            var attribute = element.attributes[i];\r\n            var name = attribute.name || attribute.nodeName;\r\n            var value = (attribute.value || attribute.nodeValue)\r\n                .replace(/&/g, '&amp;')\r\n                .replace(/</g, '&lt;')\r\n                .replace(/>/g, '&gt;')\r\n                .replace(/\"/g, '&quot;')\r\n                .replace(/'/g, '&apos;');\r\n            result += ' ' + name + '=\"' + value + '\"';\r\n        }\r\n\r\n        if (element.childNodes.length > 0) {\r\n            result += '>';\r\n\r\n            // recursively add any child elements\r\n            for (i = 0; i < element.childNodes.length; i++) {\r\n                var child = element.childNodes[i];\r\n                if (child.nodeType === 1) {\r\n                    result += serializeSvgContent(child);\r\n                } else if (child.nodeType === 3) {\r\n                    result += child.nodeValue\r\n                        .replace(/&/g, '&amp;')\r\n                        .replace(/</g, '&lt;')\r\n                        .replace(/>/g, '&gt;')\r\n                        .replace(/\"/g, '&quot;')\r\n                        .replace(/'/g, '&apos;');\r\n                }\r\n            }\r\n            result += '</' + element.nodeName + '>';\r\n\r\n        } else {\r\n            result += '/>';\r\n        }\r\n        return result;\r\n    }\r\n\r\n    Object.defineProperty(SVGElement.prototype, 'outerHTML', {\r\n        get: function () {\r\n            return serializeSvgContent(this);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n\r\n    // patches svg() function on svgjs library to use the custom serialization function for svg in IE\r\n    function newSvg(svg) {\r\n        // create temporary holder\r\n        var well = document.createElement('svg');\r\n\r\n        // act as a setter if svg is given\r\n        if (svg && this instanceof SVG.Parent) {\r\n            // dump raw svg\r\n            well.innerHTML = '<svg>' + svg.replace(/\\n/, '').replace(/<(\\w+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>';\r\n\r\n            // transplant nodes\r\n            for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++);\r\n            this.node.appendChild(well.firstChild.firstChild);\r\n\r\n            // otherwise act as a getter\r\n        } else {\r\n            // create a wrapping svg element in case of partial content\r\n            well.appendChild(svg = document.createElement('svg'));\r\n\r\n            // write svgjs data to the dom\r\n            this.writeDataToDom();\r\n\r\n            // insert a copy of this node\r\n            svg.appendChild(this.node.cloneNode(true));\r\n\r\n            // return target element\r\n            return serializeSvgContent(svg).replace(/^<svg>/i, '').replace(/<\\/svg>$/i, '');\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // defer patching until the SVGjs library is loaded; function in `_deferredPolyfills` will be executed by the bootstrap\r\n    const RV = window.RV = typeof window.RV === 'undefined' ? {} : window.RV;\r\n    (RV._deferredPolyfills = RV._deferredPolyfills || []).push(\r\n        function () { SVG.extend(SVG.Element, { svg: newSvg }) });\r\n} ());\r\n// jshint freeze:true\r\n// jshint bitwise: false\r\n\n/*!\r\n * @overview es6-promise - a tiny implementation of Promises/A+.\r\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\r\n * @license   Licensed under MIT license\r\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\r\n * @version   3.2.1\r\n */\r\n\r\n// jscs:disable\r\n/* jshint ignore:start */\r\n\r\n(function() {\r\n    \"use strict\";\r\n    function lib$es6$promise$utils$$objectOrFunction(x) {\r\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\r\n    }\r\n\r\n    function lib$es6$promise$utils$$isFunction(x) {\r\n      return typeof x === 'function';\r\n    }\r\n\r\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\r\n      return typeof x === 'object' && x !== null;\r\n    }\r\n\r\n    var lib$es6$promise$utils$$_isArray;\r\n    if (!Array.isArray) {\r\n      lib$es6$promise$utils$$_isArray = function (x) {\r\n        return Object.prototype.toString.call(x) === '[object Array]';\r\n      };\r\n    } else {\r\n      lib$es6$promise$utils$$_isArray = Array.isArray;\r\n    }\r\n\r\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\r\n    var lib$es6$promise$asap$$len = 0;\r\n    var lib$es6$promise$asap$$vertxNext;\r\n    var lib$es6$promise$asap$$customSchedulerFn;\r\n\r\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\r\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\r\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\r\n      lib$es6$promise$asap$$len += 2;\r\n      if (lib$es6$promise$asap$$len === 2) {\r\n        // If len is 2, that means that we need to schedule an async flush.\r\n        // If additional callbacks are queued before the queue is flushed, they\r\n        // will be processed by this flush that we are scheduling.\r\n        if (lib$es6$promise$asap$$customSchedulerFn) {\r\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\r\n        } else {\r\n          lib$es6$promise$asap$$scheduleFlush();\r\n        }\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\r\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\r\n    }\r\n\r\n    function lib$es6$promise$asap$$setAsap(asapFn) {\r\n      lib$es6$promise$asap$$asap = asapFn;\r\n    }\r\n\r\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\r\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\r\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\r\n    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\r\n\r\n    // test for web worker but not in IE10\r\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\r\n      typeof importScripts !== 'undefined' &&\r\n      typeof MessageChannel !== 'undefined';\r\n\r\n    // node\r\n    function lib$es6$promise$asap$$useNextTick() {\r\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\r\n      // see https://github.com/cujojs/when/issues/410 for details\r\n      return function() {\r\n        process.nextTick(lib$es6$promise$asap$$flush);\r\n      };\r\n    }\r\n\r\n    // vertx\r\n    function lib$es6$promise$asap$$useVertxTimer() {\r\n      return function() {\r\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\r\n      };\r\n    }\r\n\r\n    function lib$es6$promise$asap$$useMutationObserver() {\r\n      var iterations = 0;\r\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\r\n      var node = document.createTextNode('');\r\n      observer.observe(node, { characterData: true });\r\n\r\n      return function() {\r\n        node.data = (iterations = ++iterations % 2);\r\n      };\r\n    }\r\n\r\n    // web worker\r\n    function lib$es6$promise$asap$$useMessageChannel() {\r\n      var channel = new MessageChannel();\r\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\r\n      return function () {\r\n        channel.port2.postMessage(0);\r\n      };\r\n    }\r\n\r\n    function lib$es6$promise$asap$$useSetTimeout() {\r\n      return function() {\r\n        setTimeout(lib$es6$promise$asap$$flush, 1);\r\n      };\r\n    }\r\n\r\n    var lib$es6$promise$asap$$queue = new Array(1000);\r\n    function lib$es6$promise$asap$$flush() {\r\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\r\n        var callback = lib$es6$promise$asap$$queue[i];\r\n        var arg = lib$es6$promise$asap$$queue[i+1];\r\n\r\n        callback(arg);\r\n\r\n        lib$es6$promise$asap$$queue[i] = undefined;\r\n        lib$es6$promise$asap$$queue[i+1] = undefined;\r\n      }\r\n\r\n      lib$es6$promise$asap$$len = 0;\r\n    }\r\n\r\n    function lib$es6$promise$asap$$attemptVertx() {\r\n      try {\r\n        var r = require;\r\n        var vertx = r('vertx');\r\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\r\n        return lib$es6$promise$asap$$useVertxTimer();\r\n      } catch(e) {\r\n        return lib$es6$promise$asap$$useSetTimeout();\r\n      }\r\n    }\r\n\r\n    var lib$es6$promise$asap$$scheduleFlush;\r\n    // Decide what async method to use to triggering processing of queued callbacks:\r\n    if (lib$es6$promise$asap$$isNode) {\r\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\r\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\r\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\r\n    } else if (lib$es6$promise$asap$$isWorker) {\r\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\r\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\r\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\r\n    } else {\r\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\r\n    }\r\n    function lib$es6$promise$then$$then(onFulfillment, onRejection) {\r\n      var parent = this;\r\n\r\n      var child = new this.constructor(lib$es6$promise$$internal$$noop);\r\n\r\n      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {\r\n        lib$es6$promise$$internal$$makePromise(child);\r\n      }\r\n\r\n      var state = parent._state;\r\n\r\n      if (state) {\r\n        var callback = arguments[state - 1];\r\n        lib$es6$promise$asap$$asap(function(){\r\n          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);\r\n        });\r\n      } else {\r\n        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\r\n      }\r\n\r\n      return child;\r\n    }\r\n    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;\r\n    function lib$es6$promise$promise$resolve$$resolve(object) {\r\n      var Constructor = this;\r\n\r\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\r\n        return object;\r\n      }\r\n\r\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\r\n      lib$es6$promise$$internal$$resolve(promise, object);\r\n      return promise;\r\n    }\r\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\r\n    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);\r\n\r\n    function lib$es6$promise$$internal$$noop() {}\r\n\r\n    var lib$es6$promise$$internal$$PENDING   = void 0;\r\n    var lib$es6$promise$$internal$$FULFILLED = 1;\r\n    var lib$es6$promise$$internal$$REJECTED  = 2;\r\n\r\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\r\n\r\n    function lib$es6$promise$$internal$$selfFulfillment() {\r\n      return new TypeError(\"You cannot resolve a promise with itself\");\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\r\n      return new TypeError('A promises callback cannot return that same promise.');\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$getThen(promise) {\r\n      try {\r\n        return promise.then;\r\n      } catch(error) {\r\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\r\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\r\n      try {\r\n        then.call(value, fulfillmentHandler, rejectionHandler);\r\n      } catch(e) {\r\n        return e;\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\r\n       lib$es6$promise$asap$$asap(function(promise) {\r\n        var sealed = false;\r\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\r\n          if (sealed) { return; }\r\n          sealed = true;\r\n          if (thenable !== value) {\r\n            lib$es6$promise$$internal$$resolve(promise, value);\r\n          } else {\r\n            lib$es6$promise$$internal$$fulfill(promise, value);\r\n          }\r\n        }, function(reason) {\r\n          if (sealed) { return; }\r\n          sealed = true;\r\n\r\n          lib$es6$promise$$internal$$reject(promise, reason);\r\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\r\n\r\n        if (!sealed && error) {\r\n          sealed = true;\r\n          lib$es6$promise$$internal$$reject(promise, error);\r\n        }\r\n      }, promise);\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\r\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\r\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\r\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\r\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\r\n      } else {\r\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\r\n          lib$es6$promise$$internal$$resolve(promise, value);\r\n        }, function(reason) {\r\n          lib$es6$promise$$internal$$reject(promise, reason);\r\n        });\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {\r\n      if (maybeThenable.constructor === promise.constructor &&\r\n          then === lib$es6$promise$then$$default &&\r\n          constructor.resolve === lib$es6$promise$promise$resolve$$default) {\r\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\r\n      } else {\r\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\r\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\r\n        } else if (then === undefined) {\r\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\r\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\r\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\r\n        } else {\r\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\r\n        }\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$resolve(promise, value) {\r\n      if (promise === value) {\r\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\r\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\r\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));\r\n      } else {\r\n        lib$es6$promise$$internal$$fulfill(promise, value);\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$publishRejection(promise) {\r\n      if (promise._onerror) {\r\n        promise._onerror(promise._result);\r\n      }\r\n\r\n      lib$es6$promise$$internal$$publish(promise);\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\r\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\r\n\r\n      promise._result = value;\r\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\r\n\r\n      if (promise._subscribers.length !== 0) {\r\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$reject(promise, reason) {\r\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\r\n      promise._state = lib$es6$promise$$internal$$REJECTED;\r\n      promise._result = reason;\r\n\r\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\r\n      var subscribers = parent._subscribers;\r\n      var length = subscribers.length;\r\n\r\n      parent._onerror = null;\r\n\r\n      subscribers[length] = child;\r\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\r\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\r\n\r\n      if (length === 0 && parent._state) {\r\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$publish(promise) {\r\n      var subscribers = promise._subscribers;\r\n      var settled = promise._state;\r\n\r\n      if (subscribers.length === 0) { return; }\r\n\r\n      var child, callback, detail = promise._result;\r\n\r\n      for (var i = 0; i < subscribers.length; i += 3) {\r\n        child = subscribers[i];\r\n        callback = subscribers[i + settled];\r\n\r\n        if (child) {\r\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\r\n        } else {\r\n          callback(detail);\r\n        }\r\n      }\r\n\r\n      promise._subscribers.length = 0;\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$ErrorObject() {\r\n      this.error = null;\r\n    }\r\n\r\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\r\n\r\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\r\n      try {\r\n        return callback(detail);\r\n      } catch(e) {\r\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\r\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\r\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\r\n          value, error, succeeded, failed;\r\n\r\n      if (hasCallback) {\r\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\r\n\r\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\r\n          failed = true;\r\n          error = value.error;\r\n          value = null;\r\n        } else {\r\n          succeeded = true;\r\n        }\r\n\r\n        if (promise === value) {\r\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\r\n          return;\r\n        }\r\n\r\n      } else {\r\n        value = detail;\r\n        succeeded = true;\r\n      }\r\n\r\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\r\n        // noop\r\n      } else if (hasCallback && succeeded) {\r\n        lib$es6$promise$$internal$$resolve(promise, value);\r\n      } else if (failed) {\r\n        lib$es6$promise$$internal$$reject(promise, error);\r\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\r\n        lib$es6$promise$$internal$$fulfill(promise, value);\r\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\r\n        lib$es6$promise$$internal$$reject(promise, value);\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\r\n      try {\r\n        resolver(function resolvePromise(value){\r\n          lib$es6$promise$$internal$$resolve(promise, value);\r\n        }, function rejectPromise(reason) {\r\n          lib$es6$promise$$internal$$reject(promise, reason);\r\n        });\r\n      } catch(e) {\r\n        lib$es6$promise$$internal$$reject(promise, e);\r\n      }\r\n    }\r\n\r\n    var lib$es6$promise$$internal$$id = 0;\r\n    function lib$es6$promise$$internal$$nextId() {\r\n      return lib$es6$promise$$internal$$id++;\r\n    }\r\n\r\n    function lib$es6$promise$$internal$$makePromise(promise) {\r\n      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;\r\n      promise._state = undefined;\r\n      promise._result = undefined;\r\n      promise._subscribers = [];\r\n    }\r\n\r\n    function lib$es6$promise$promise$all$$all(entries) {\r\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\r\n    }\r\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\r\n    function lib$es6$promise$promise$race$$race(entries) {\r\n      var Constructor = this;\r\n\r\n      if (!lib$es6$promise$utils$$isArray(entries)) {\r\n        return new Constructor(function(resolve, reject) {\r\n          reject(new TypeError('You must pass an array to race.'));\r\n        });\r\n      } else {\r\n        return new Constructor(function(resolve, reject) {\r\n          var length = entries.length;\r\n          for (var i = 0; i < length; i++) {\r\n            Constructor.resolve(entries[i]).then(resolve, reject);\r\n          }\r\n        });\r\n      }\r\n    }\r\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\r\n    function lib$es6$promise$promise$reject$$reject(reason) {\r\n      var Constructor = this;\r\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\r\n      lib$es6$promise$$internal$$reject(promise, reason);\r\n      return promise;\r\n    }\r\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\r\n\r\n\r\n    function lib$es6$promise$promise$$needsResolver() {\r\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\r\n    }\r\n\r\n    function lib$es6$promise$promise$$needsNew() {\r\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\r\n    }\r\n\r\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\r\n    /**\r\n      Promise objects represent the eventual result of an asynchronous operation. The\r\n      primary way of interacting with a promise is through its `then` method, which\r\n      registers callbacks to receive either a promise's eventual value or the reason\r\n      why the promise cannot be fulfilled.\r\n\r\n      Terminology\r\n      -----------\r\n\r\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\r\n      - `thenable` is an object or function that defines a `then` method.\r\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\r\n      - `exception` is a value that is thrown using the throw statement.\r\n      - `reason` is a value that indicates why a promise was rejected.\r\n      - `settled` the final resting state of a promise, fulfilled or rejected.\r\n\r\n      A promise can be in one of three states: pending, fulfilled, or rejected.\r\n\r\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\r\n      state.  Promises that are rejected have a rejection reason and are in the\r\n      rejected state.  A fulfillment value is never a thenable.\r\n\r\n      Promises can also be said to *resolve* a value.  If this value is also a\r\n      promise, then the original promise's settled state will match the value's\r\n      settled state.  So a promise that *resolves* a promise that rejects will\r\n      itself reject, and a promise that *resolves* a promise that fulfills will\r\n      itself fulfill.\r\n\r\n\r\n      Basic Usage:\r\n      ------------\r\n\r\n      ```js\r\n      var promise = new Promise(function(resolve, reject) {\r\n        // on success\r\n        resolve(value);\r\n\r\n        // on failure\r\n        reject(reason);\r\n      });\r\n\r\n      promise.then(function(value) {\r\n        // on fulfillment\r\n      }, function(reason) {\r\n        // on rejection\r\n      });\r\n      ```\r\n\r\n      Advanced Usage:\r\n      ---------------\r\n\r\n      Promises shine when abstracting away asynchronous interactions such as\r\n      `XMLHttpRequest`s.\r\n\r\n      ```js\r\n      function getJSON(url) {\r\n        return new Promise(function(resolve, reject){\r\n          var xhr = new XMLHttpRequest();\r\n\r\n          xhr.open('GET', url);\r\n          xhr.onreadystatechange = handler;\r\n          xhr.responseType = 'json';\r\n          xhr.setRequestHeader('Accept', 'application/json');\r\n          xhr.send();\r\n\r\n          function handler() {\r\n            if (this.readyState === this.DONE) {\r\n              if (this.status === 200) {\r\n                resolve(this.response);\r\n              } else {\r\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\r\n              }\r\n            }\r\n          };\r\n        });\r\n      }\r\n\r\n      getJSON('/posts.json').then(function(json) {\r\n        // on fulfillment\r\n      }, function(reason) {\r\n        // on rejection\r\n      });\r\n      ```\r\n\r\n      Unlike callbacks, promises are great composable primitives.\r\n\r\n      ```js\r\n      Promise.all([\r\n        getJSON('/posts'),\r\n        getJSON('/comments')\r\n      ]).then(function(values){\r\n        values[0] // => postsJSON\r\n        values[1] // => commentsJSON\r\n\r\n        return values;\r\n      });\r\n      ```\r\n\r\n      @class Promise\r\n      @param {function} resolver\r\n      Useful for tooling.\r\n      @constructor\r\n    */\r\n    function lib$es6$promise$promise$$Promise(resolver) {\r\n      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();\r\n      this._result = this._state = undefined;\r\n      this._subscribers = [];\r\n\r\n      if (lib$es6$promise$$internal$$noop !== resolver) {\r\n        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();\r\n        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();\r\n      }\r\n    }\r\n\r\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\r\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\r\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\r\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\r\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\r\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\r\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\r\n\r\n    lib$es6$promise$promise$$Promise.prototype = {\r\n      constructor: lib$es6$promise$promise$$Promise,\r\n\r\n    /**\r\n      The primary way of interacting with a promise is through its `then` method,\r\n      which registers callbacks to receive either a promise's eventual value or the\r\n      reason why the promise cannot be fulfilled.\r\n\r\n      ```js\r\n      findUser().then(function(user){\r\n        // user is available\r\n      }, function(reason){\r\n        // user is unavailable, and you are given the reason why\r\n      });\r\n      ```\r\n\r\n      Chaining\r\n      --------\r\n\r\n      The return value of `then` is itself a promise.  This second, 'downstream'\r\n      promise is resolved with the return value of the first promise's fulfillment\r\n      or rejection handler, or rejected if the handler throws an exception.\r\n\r\n      ```js\r\n      findUser().then(function (user) {\r\n        return user.name;\r\n      }, function (reason) {\r\n        return 'default name';\r\n      }).then(function (userName) {\r\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\r\n        // will be `'default name'`\r\n      });\r\n\r\n      findUser().then(function (user) {\r\n        throw new Error('Found user, but still unhappy');\r\n      }, function (reason) {\r\n        throw new Error('`findUser` rejected and we're unhappy');\r\n      }).then(function (value) {\r\n        // never reached\r\n      }, function (reason) {\r\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\r\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\r\n      });\r\n      ```\r\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\r\n\r\n      ```js\r\n      findUser().then(function (user) {\r\n        throw new PedagogicalException('Upstream error');\r\n      }).then(function (value) {\r\n        // never reached\r\n      }).then(function (value) {\r\n        // never reached\r\n      }, function (reason) {\r\n        // The `PedgagocialException` is propagated all the way down to here\r\n      });\r\n      ```\r\n\r\n      Assimilation\r\n      ------------\r\n\r\n      Sometimes the value you want to propagate to a downstream promise can only be\r\n      retrieved asynchronously. This can be achieved by returning a promise in the\r\n      fulfillment or rejection handler. The downstream promise will then be pending\r\n      until the returned promise is settled. This is called *assimilation*.\r\n\r\n      ```js\r\n      findUser().then(function (user) {\r\n        return findCommentsByAuthor(user);\r\n      }).then(function (comments) {\r\n        // The user's comments are now available\r\n      });\r\n      ```\r\n\r\n      If the assimliated promise rejects, then the downstream promise will also reject.\r\n\r\n      ```js\r\n      findUser().then(function (user) {\r\n        return findCommentsByAuthor(user);\r\n      }).then(function (comments) {\r\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\r\n      }, function (reason) {\r\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\r\n      });\r\n      ```\r\n\r\n      Simple Example\r\n      --------------\r\n\r\n      Synchronous Example\r\n\r\n      ```javascript\r\n      var result;\r\n\r\n      try {\r\n        result = findResult();\r\n        // success\r\n      } catch(reason) {\r\n        // failure\r\n      }\r\n      ```\r\n\r\n      Errback Example\r\n\r\n      ```js\r\n      findResult(function(result, err){\r\n        if (err) {\r\n          // failure\r\n        } else {\r\n          // success\r\n        }\r\n      });\r\n      ```\r\n\r\n      Promise Example;\r\n\r\n      ```javascript\r\n      findResult().then(function(result){\r\n        // success\r\n      }, function(reason){\r\n        // failure\r\n      });\r\n      ```\r\n\r\n      Advanced Example\r\n      --------------\r\n\r\n      Synchronous Example\r\n\r\n      ```javascript\r\n      var author, books;\r\n\r\n      try {\r\n        author = findAuthor();\r\n        books  = findBooksByAuthor(author);\r\n        // success\r\n      } catch(reason) {\r\n        // failure\r\n      }\r\n      ```\r\n\r\n      Errback Example\r\n\r\n      ```js\r\n\r\n      function foundBooks(books) {\r\n\r\n      }\r\n\r\n      function failure(reason) {\r\n\r\n      }\r\n\r\n      findAuthor(function(author, err){\r\n        if (err) {\r\n          failure(err);\r\n          // failure\r\n        } else {\r\n          try {\r\n            findBoooksByAuthor(author, function(books, err) {\r\n              if (err) {\r\n                failure(err);\r\n              } else {\r\n                try {\r\n                  foundBooks(books);\r\n                } catch(reason) {\r\n                  failure(reason);\r\n                }\r\n              }\r\n            });\r\n          } catch(error) {\r\n            failure(err);\r\n          }\r\n          // success\r\n        }\r\n      });\r\n      ```\r\n\r\n      Promise Example;\r\n\r\n      ```javascript\r\n      findAuthor().\r\n        then(findBooksByAuthor).\r\n        then(function(books){\r\n          // found books\r\n      }).catch(function(reason){\r\n        // something went wrong\r\n      });\r\n      ```\r\n\r\n      @method then\r\n      @param {Function} onFulfilled\r\n      @param {Function} onRejected\r\n      Useful for tooling.\r\n      @return {Promise}\r\n    */\r\n      then: lib$es6$promise$then$$default,\r\n\r\n    /**\r\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\r\n      as the catch block of a try/catch statement.\r\n\r\n      ```js\r\n      function findAuthor(){\r\n        throw new Error('couldn't find that author');\r\n      }\r\n\r\n      // synchronous\r\n      try {\r\n        findAuthor();\r\n      } catch(reason) {\r\n        // something went wrong\r\n      }\r\n\r\n      // async with promises\r\n      findAuthor().catch(function(reason){\r\n        // something went wrong\r\n      });\r\n      ```\r\n\r\n      @method catch\r\n      @param {Function} onRejection\r\n      Useful for tooling.\r\n      @return {Promise}\r\n    */\r\n      'catch': function(onRejection) {\r\n        return this.then(null, onRejection);\r\n      }\r\n    };\r\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\r\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\r\n      this._instanceConstructor = Constructor;\r\n      this.promise = new Constructor(lib$es6$promise$$internal$$noop);\r\n\r\n      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {\r\n        lib$es6$promise$$internal$$makePromise(this.promise);\r\n      }\r\n\r\n      if (Array.isArray(input)) {\r\n        this._input     = input;\r\n        this.length     = input.length;\r\n        this._remaining = input.length;\r\n\r\n        this._result = new Array(this.length);\r\n\r\n        if (this.length === 0) {\r\n          lib$es6$promise$$internal$$fulfill(this.promise, this._result);\r\n        } else {\r\n          this.length = this.length || 0;\r\n          this._enumerate();\r\n          if (this._remaining === 0) {\r\n            lib$es6$promise$$internal$$fulfill(this.promise, this._result);\r\n          }\r\n        }\r\n      } else {\r\n        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());\r\n      }\r\n    }\r\n\r\n    function lib$es6$promise$enumerator$$validationError() {\r\n      return new Error('Array Methods must be provided an Array');\r\n    }\r\n\r\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\r\n      var length  = this.length;\r\n      var input   = this._input;\r\n\r\n      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\r\n        this._eachEntry(input[i], i);\r\n      }\r\n    };\r\n\r\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\r\n      var c = this._instanceConstructor;\r\n      var resolve = c.resolve;\r\n\r\n      if (resolve === lib$es6$promise$promise$resolve$$default) {\r\n        var then = lib$es6$promise$$internal$$getThen(entry);\r\n\r\n        if (then === lib$es6$promise$then$$default &&\r\n            entry._state !== lib$es6$promise$$internal$$PENDING) {\r\n          this._settledAt(entry._state, i, entry._result);\r\n        } else if (typeof then !== 'function') {\r\n          this._remaining--;\r\n          this._result[i] = entry;\r\n        } else if (c === lib$es6$promise$promise$$default) {\r\n          var promise = new c(lib$es6$promise$$internal$$noop);\r\n          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);\r\n          this._willSettleAt(promise, i);\r\n        } else {\r\n          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);\r\n        }\r\n      } else {\r\n        this._willSettleAt(resolve(entry), i);\r\n      }\r\n    };\r\n\r\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\r\n      var promise = this.promise;\r\n\r\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\r\n        this._remaining--;\r\n\r\n        if (state === lib$es6$promise$$internal$$REJECTED) {\r\n          lib$es6$promise$$internal$$reject(promise, value);\r\n        } else {\r\n          this._result[i] = value;\r\n        }\r\n      }\r\n\r\n      if (this._remaining === 0) {\r\n        lib$es6$promise$$internal$$fulfill(promise, this._result);\r\n      }\r\n    };\r\n\r\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\r\n      var enumerator = this;\r\n\r\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\r\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\r\n      }, function(reason) {\r\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\r\n      });\r\n    };\r\n    function lib$es6$promise$polyfill$$polyfill() {\r\n      var local;\r\n\r\n      if (typeof global !== 'undefined') {\r\n          local = global;\r\n      } else if (typeof self !== 'undefined') {\r\n          local = self;\r\n      } else {\r\n          try {\r\n              local = Function('return this')();\r\n          } catch (e) {\r\n              throw new Error('polyfill failed because global object is unavailable in this environment');\r\n          }\r\n      }\r\n\r\n      var P = local.Promise;\r\n\r\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\r\n        return;\r\n      }\r\n\r\n      local.Promise = lib$es6$promise$promise$$default;\r\n    }\r\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\r\n\r\n    var lib$es6$promise$umd$$ES6Promise = {\r\n      'Promise': lib$es6$promise$promise$$default,\r\n      'polyfill': lib$es6$promise$polyfill$$default\r\n    };\r\n\r\n    if (typeof define === 'function' && define['amd']) {\r\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\r\n    } else if (typeof module !== 'undefined' && module['exports']) {\r\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\r\n    } else if (typeof this !== 'undefined') {\r\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\r\n    }\r\n\r\n    lib$es6$promise$polyfill$$default();\r\n}).call(window);\r\n\r\nwindow['ES6Promise'].polyfill();\r\n\r\n\r\n// jscs:enable\r\n/* jshint ignore:end */\r\n\n// jscs:disable\r\n/* jshint ignore:start */\r\n\r\nif (!String.prototype.endsWith) {\r\n    String.prototype.endsWith = function (searchString, position) {\r\n        var subjectString = this.toString();\r\n        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\r\n            position = subjectString.length;\r\n        }\r\n        position -= searchString.length;\r\n        var lastIndex = subjectString.indexOf(searchString, position);\r\n        return lastIndex !== -1 && lastIndex === position;\r\n    };\r\n}\r\n\r\n// jscs:enable\r\n/* jshint ignore:end */\r\n\n// jscs:disable\r\n/* jshint ignore:start */\r\n\r\nif (!String.prototype.repeat) {\r\n  String.prototype.repeat = function(count) {\r\n    'use strict';\r\n    if (this == null) {\r\n      throw new TypeError('can\\'t convert ' + this + ' to object');\r\n    }\r\n    var str = '' + this;\r\n    count = +count;\r\n    if (count != count) {\r\n      count = 0;\r\n    }\r\n    if (count < 0) {\r\n      throw new RangeError('repeat count must be non-negative');\r\n    }\r\n    if (count == Infinity) {\r\n      throw new RangeError('repeat count must be less than infinity');\r\n    }\r\n    count = Math.floor(count);\r\n    if (str.length == 0 || count == 0) {\r\n      return '';\r\n    }\r\n    // Ensuring count is a 31-bit integer allows us to heavily optimize the\r\n    // main part. But anyway, most current (August 2014) browsers can't handle\r\n    // strings 1 << 28 chars or longer, so:\r\n    if (str.length * count >= 1 << 28) {\r\n      throw new RangeError('repeat count must not overflow maximum string size');\r\n    }\r\n    var rpt = '';\r\n    for (;;) {\r\n      if ((count & 1) == 1) {\r\n        rpt += str;\r\n      }\r\n      count >>>= 1;\r\n      if (count == 0) {\r\n        break;\r\n      }\r\n      str += str;\r\n    }\r\n    // Could we try:\r\n    // return Array(count + 1).join(this);\r\n    return rpt;\r\n  }\r\n}\n// jscs:disable\r\n/* jshint ignore:start */\r\n\r\nif (!String.prototype.startsWith) {\r\n    String.prototype.startsWith = function (searchString, position){\r\n      position = position || 0;\r\n      return this.substr(position, searchString.length) === searchString;\r\n  };\r\n}\r\n\r\n// jscs:enable\r\n/* jshint ignore:end */\r\n"]}